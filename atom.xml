<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lyhlyhaa.github.io</id>
    <title>混子协会会长</title>
    <updated>2020-07-27T09:07:40.327Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lyhlyhaa.github.io"/>
    <link rel="self" href="https://lyhlyhaa.github.io/atom.xml"/>
    <logo>https://lyhlyhaa.github.io/images/avatar.png</logo>
    <icon>https://lyhlyhaa.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 混子协会会长</rights>
    <entry>
        <title type="html"><![CDATA[最小生成树]]></title>
        <id>https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/">
        </link>
        <updated>2020-07-26T07:00:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="克鲁斯卡尔算法">克鲁斯卡尔算法：</h1>
<p>1.把边进行排序，按从从小到大的顺序。<br>
2.贪心算法，找未加入通路的权值最小的边<br>
3.判断是否形成环，如果形成，则跳过这一条边，返回第二步，如果没有，则把找到的边加入通路中，返回第二步<br>
4.当通路中的的边的个数等于点的个数-1，则最小生成树已经形成。</p>
<p><em>排序可以用sort函数，边的存储可以用结构体数组</em><br>
<strong>主要是判断是否形成环：</strong><br>
使用<a href="https://blog.csdn.net/qq_41593380/article/details/81146850">并查集</a><br>
<strong>初始化</strong></p>
<pre><code>void init(int n)
{
    for (int i = 1; i &lt;= n; ++i)
        fa[i] = i;
}
</code></pre>
<p><strong>路径压缩查找</strong></p>
<pre><code>int find(int x)
{
    return x == fa[x] ? x : (fa[x] = find(fa[x]));//
}
</code></pre>
<p><strong>合并</strong></p>
<pre><code>ivoid merge(int i, int j)
{
    fa[find(i)] = find(j);
}//合并
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐波拉契数列]]></title>
        <id>https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/</id>
        <link href="https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/">
        </link>
        <updated>2020-07-24T07:30:17.000Z</updated>
        <content type="html"><![CDATA[<p>。。。。<br>
今晚整理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[骨牌问题（铺地砖）]]></title>
        <id>https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/</id>
        <link href="https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/">
        </link>
        <updated>2020-07-24T07:14:41.000Z</updated>
        <content type="html"><![CDATA[<p>暂时看一下别的博客（https://blog.csdn.net/xiangAccepted/article/details/80229187?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三色旗问题]]></title>
        <id>https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/</id>
        <link href="https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/">
        </link>
        <updated>2020-07-24T02:54:57.000Z</updated>
        <content type="html"><![CDATA[<p>要用到三个指针：一个前指针begin，一个中指针current，一个后指针end，current指针遍历整个数组序列，当</p>
<p>current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ；<br>
current指针所指元素为1时，不做任何交换（即球不动），而后current++ ；<br>
current指针所指元素为2时，与end指针所指的元素交换，而后，current指针不动，end-- 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-suan-ji-wang-luo/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-suan-ji-wang-luo/">
        </link>
        <updated>2020-07-23T08:31:33.000Z</updated>
        <content type="html"><![CDATA[<p>浏览器是一个具备多种客户端功能的综合性客户端软件，因此它需要一些东西来判断应该使用其中哪种功能来访问相应的数据，而各种不同的URL就是用来干这个的，比如访问Web服务器时用“http:”，而访问FTP服务器时用“ftp:”。</p>
<p>如图1.9所示，实际的IP地址是一串32比特的数字，按照8比特（1字节）为一组分成4组，分别用十进制表示然后再用圆点隔开</p>
<p>IP地址的主机号全0：表示整个子网全1：表示向子网上所有设备发送包，即“广播”</p>
<p>顺带一提，向DNS服务器发送消息时，我们当然也需要知道DNS服务器的IP地址。只不过这个IP地址是作为TCP/IP的一个设置项目事先设置好的，不需要再去查询了。<br>
DNS服务器会从域名与IP地址的对照表中查找相应的记录，并返回IP地址。</p>
<p>管道在连接时是由客户端发起的，但在断开时可以由客户端或服务器任意一方发起[插图]。其中一方断开后，另一方也会随之断开，当管道断开后，套接字也会被删除。到此为止，通信操作就结束了。综上所述，收发数据的操作分为若干个阶段，可以大致总结为以下4个。（1）创建套接字（创建套接字阶段）（2）将管道连接到服务器端的套接字上（连接阶段）（3）收发数据（通信阶段）（4）断开管道并删除套接字（断开阶段）</p>
<p>描述符：应用程序用来识别套接字的机制IP地址和端口号：客户端和服务器之间用来识别对方套接字的机制</p>
<p>而将网络包发送给通信对象的操作就是由IP来负责的。此外，IP中还包括ICMP协议和ARP协议。ICMP用于告知网络包传送过程中产生的错误以及各种控制消息，ARP用于根据IP地址查询相应的以太网MAC地址。</p>
<p>通信操作中使用的控制信息分为两类。（1）头部中记录的信息（2）套接字（协议栈中的内存空间）中记录的信息</p>
<p>MTU：一个网络包的最大长度，以太网中一般为1500字节。MSS：除去头部之后，一个网络包所能容纳的TCP数据的最大长度</p>
<p>通过“序号”和“ACK号”可以确认接收方是否收到了网络包。</p>
<p>TCP采用了动态调整等待时间的方法，这个等待时间是根据ACK号返回所需的时间来判断的。具体来说，TCP会在发送数据的过程中持续测量ACK号的返回时间，如果ACK号返回变慢，则相应延长等待时间；相对地，如果ACK号马上就能返回，则相应缩短等待时间</p>
<p>首先，什么时候需要更新窗口大小呢？<br>
这个操作是接收方应用程序发出请求时才会进行的，而发送方不知道什么时候会进行这样的操作，因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，就需要告知发送方，这就是更新窗口大小的时机。<br>
 <br>
协议栈在设计上允许任何一方先发起断开过程。</p>
<p>（1）路由器根据目标地址判断下一个路由器的位置（2）集线器在子网中将网络包传输到下一个路由</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路径算法]]></title>
        <id>https://lyhlyhaa.github.io/post/zui-duan-lu-jing-suan-fa/</id>
        <link href="https://lyhlyhaa.github.io/post/zui-duan-lu-jing-suan-fa/">
        </link>
        <updated>2020-07-22T12:05:34.000Z</updated>
        <content type="html"><![CDATA[<p>说起来这个算法做过很多次了，学图论的时候写过实验报告，可是现在做题又给忘了，惭愧。</p>
<hr>
<h1 id="dijkstra算法">Dijkstra算法</h1>
<p>1.<strong>初始化</strong>:先找出从源点vo到各终点v的直达路径(Vo,Vk) ,<br>
即通过一条弧到达的路径。<br>
2.<strong>选择</strong>:从这些路径中找出一条长度最短的路径(Vo,u) 。<br>
3.<strong>更新</strong>:然后对其余各条路径进行适当调整:<br>
若在图中存在弧(u,Vk) ，且(V,U) + (u,Vk) &lt; (Vo,Vk),<br>
则以路径(Vo,U,Vk) 代替(Vo,Vk) 。<br>
在调整后的各条路径中，再找长度最短的路径，依此类推。<br>
设计一个s[]数组，来存已经在最短路径中的点</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dp]]></title>
        <id>https://lyhlyhaa.github.io/post/dp/</id>
        <link href="https://lyhlyhaa.github.io/post/dp/">
        </link>
        <updated>2020-07-22T01:53:51.000Z</updated>
        <content type="html"><![CDATA[<p>先是不说人话的概念：dp（动态规划）是求解决策过程最优化的数学方法。利用各个阶段之间的关系，逐个求解，最终求得全局最优解，需要确认原问题与子问题、动态规划状态、边界状态、边界状态结值、状态转移方程<br>
看不懂啊！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈]]></title>
        <id>https://lyhlyhaa.github.io/post/zhan/</id>
        <link href="https://lyhlyhaa.github.io/post/zhan/">
        </link>
        <updated>2020-07-21T01:59:07.000Z</updated>
        <content type="html"><![CDATA[<p>栈（stack）说明及举例：</p>
<p>使用栈，要先包含头文件 ： <code>#include&lt;stack&gt;</code></p>
<p>定义栈，以如下形式实现： <code>stack&lt;Type&gt; s;</code> 其中Type为数据类型（如 int，float,char等）。</p>
<p>栈的主要操作：</p>
<pre><code>s.push(item);		//将item压入栈顶
s.pop();			//删除栈顶的元素，但不会返回
s.top();			//返回栈顶的元素，但不会删除
s.size();			//返回栈中元素的个数
s.empty();			//检查栈是否为空，如果为空返回true，否则返回false 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[指针疑问]]></title>
        <id>https://lyhlyhaa.github.io/post/zhi-zhen-yi-wen/</id>
        <link href="https://lyhlyhaa.github.io/post/zhi-zhen-yi-wen/">
        </link>
        <updated>2020-07-20T09:05:40.000Z</updated>
        <content type="html"><![CDATA[<p>指针<br>
*号：指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。* 运算符，也称为间接访问运算符，返回指针指向存储单元的数值；也称为指向运算符号：<br>
注意：<br>
指针运算符是取地址运算符号的反运算符号<br>
*(&amp;a) = 10;<br>
&amp;号：每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址，&amp;运算符，返回操作数的内存地址</p>
<pre><code class="language-cpp">int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
   ip = &amp;var;  /* 在指针变量中存储 var 的地址 */
   printf(&quot;Address of var variable: %p\n&quot;, &amp;var  );//Address of var variable: bffd8b3c
   /* 在指针变量中存储的地址 */
   printf(&quot;Address stored in ip variable: %p\n&quot;, ip );//Address stored in ip variable: bffd8b3c
   /* 使用指针访问值 */
   printf(&quot;Value of *ip variable: %d\n&quot;, *ip );//Value of *ip variable: 20
</code></pre>
<p><strong>突然想起来定义的时候，int *p就是int* p,其实是相当于一个int*类型的变量p，p就是一个地址值，简而言之，p是一个地址值，而*p就是p所指向的东西，可以是一个整型变量，也可以指向一个链表节点，也可以是一个二叉树节点。</strong></p>
<pre><code class="language-cpp"> int a=1;
 int *pa;
 pa=&amp;a; //&amp;a 是一个指针表达式。
 printf(&quot;*a=%p\n&quot;,&amp;a);
 printf(&quot;*pa=%d\n&quot;,*pa);//*pa是一个值，就是pa所指向的a的值 
 printf(&quot;pa=%p\n&quot;,pa);//pa是一个地址，pa指向a，所以pa地址与a相同 
 printf(&quot;&amp;*pa=%p\n&quot;,&amp;(*pa));//pa指向a，*pa就是a,&amp;(*pa)即*pa的地址就是a的地址 
 /*
 *a=000000000062FE14
 *pa=1
 pa=000000000062FE14
 &amp;*pa=000000000062FE14
 */
 printf(&quot;\n&quot;); 
 int** ptr;
 ptr=&amp;pa;//由此可知*ptr=pa、**ptr=*pa 
 printf(&quot;&amp;pa=%p\n&quot;,&amp;pa);//pa指针本身的地址 
 printf(&quot;ptr=%p\n&quot;,ptr);//ptr指向的是pa本身地址 
 printf(&quot;*ptr=%p\n&quot;,*ptr);//*ptr指向的是pa指针所指向的地址，就是a的地址
 printf(&quot;**p=%d\n&quot;,**ptr);// 
 /*
 &amp;pa=000000000062FE08
 *ptr=000000000062FE14
 ptr=000000000062FE08
 **p=1
 */
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树]]></title>
        <id>https://lyhlyhaa.github.io/post/er-cha-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/er-cha-shu/">
        </link>
        <updated>2020-07-20T02:39:20.000Z</updated>
        <content type="html"><![CDATA[<p>首先说一下一些基础知识。（查了一下，树的高度和深度好像有不同的说法，似乎初始值有 0 有 1）</p>
<h1 id="基础知识">基础知识</h1>
<p><em><strong>树的高度</strong></em>：<br>
节点的深度是根节点到这个节点所经历的边的个数<br>
节点的高度是该节点到叶子节点的最长路径（边数）<br>
树的高度等于根节点的高度<br>
<img src="https://lyhlyhaa.github.io/post-images/1595213437405.png" alt="" loading="lazy"><br>
（好像有些是从1开始的）<br>
递归计算高度</p>
<pre><code>int height(BitNode *root){
	if(root==NULL) return 0;
	else 
	return max(height(root-&gt;lchild),height(root-&gt;rchild))+1;
}//求二叉树的高度
</code></pre>
<h1 id="二叉查找树">二叉查找树</h1>
<h2 id="定义">定义</h2>
<p><em><strong>二叉查找树</strong></em><br>
一棵空树，或者是具有下列性质的二叉树：<br>
（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>
（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>
（3）左、右子树也分别为二叉排序树；<br>
（4）没有键值相等的结点。<br>
可以用递归建树，似乎涉及二叉树的题目，大部分是递归。</p>
<h2 id="建树">建树</h2>
<p>要建立一个二叉查找树，首先要定义一个结构体，一般来说定义的结构体都是一样的；</p>
<pre><code>typedef struct BitNode{
   int data;
   struct BitNode *lchild, *rchild; 
}BitNode,*BiTree;
</code></pre>
<p>一个数据域，还有左右节点。<br>
插入函数：</p>
<pre><code>bool BSTInsert(BitNode *p, int element)  //插入函数 
{  
    if(NULL == p) // 空树  
    {  
        p = new BitNode;  
        p-&gt;data = element;  
        p-&gt;lchild = p-&gt;rchild = NULL;  
        return true;  
    }  
    if(element == p-&gt;data) // BST中不能有相等的值  
        return false;  
    if(element &lt; p-&gt;data)  // 递归  
        return BSTInsert(p-&gt;lchild, element);  

    return BSTInsert(p-&gt;rchild, element); // 递归  
}
</code></pre>
]]></content>
    </entry>
</feed>