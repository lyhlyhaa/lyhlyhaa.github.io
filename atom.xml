<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lyhlyhaa.github.io</id>
    <title>混子协会会长</title>
    <updated>2020-08-13T09:09:43.179Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lyhlyhaa.github.io"/>
    <link rel="self" href="https://lyhlyhaa.github.io/atom.xml"/>
    <logo>https://lyhlyhaa.github.io/images/avatar.png</logo>
    <icon>https://lyhlyhaa.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 混子协会会长</rights>
    <entry>
        <title type="html"><![CDATA[逆序数]]></title>
        <id>https://lyhlyhaa.github.io/post/ni-xu-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/ni-xu-shu/">
        </link>
        <updated>2020-08-01T09:15:57.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/dlengong/article/details/7594919?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.channel_param">文章</a><br>
1.两层循环<br>
一猜就会超时，后来试了一下，果然。<br>
2.归并排序<br>
把数组分成两份，分别进行排序，然后合并<br>
会用到递归，从最开始的数组，到整个区间只有一个元素结束，即l==r<br>
<img src="https://lyhlyhaa.github.io/post-images/1596333420953.gif" alt="" loading="lazy"><br>
合并操作：<br>
<img src="https://lyhlyhaa.github.io/post-images/1596333135649.gif" alt="" loading="lazy"><br>
在两个分出来的数组比较完之后，把未填入的数组剩下的数依次（因为数组已经排好序）填入</p>
<pre><code>while(i&lt;=mid) temp[k++] = a[i++];  
while(j&lt;=right) temp[k++] = a[j++];
</code></pre>
<p>用归并求逆序数的关键就在于<br>
Seq1：3  4  5<br>
Seq2：2  6  8  9<br>
合并成一个有序序:</p>
<p>Seq：2  3  4  5  6  8  9</p>
<p>对于序列seq1中的某个数a[i],序列seq2中的某个数a[j]，如果a[i]&lt;a[j],没有逆序数，如果a[i]&gt;a[j]，那么逆序数为seq1中a[i]后边元素的个数(包括a[i])，即len1-i+1,<br>
3.<a href="http://www.cppblog.com/Ylemzy/articles/98322.html">树状数组</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统]]></title>
        <id>https://lyhlyhaa.github.io/post/cao-zuo-xi-tong/</id>
        <link href="https://lyhlyhaa.github.io/post/cao-zuo-xi-tong/">
        </link>
        <updated>2020-08-01T02:21:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第1章-操作系统概述">第1章 操作系统概述</h1>
<h2 id="11-什么是操作系统">1.1 什么是操作系统</h2>
<p><em>操作系统的定义（掌握）</em><br>
操作系统是计算机系统中最基础，最重要的<strong>系统软件</strong>，是其他软件的支撑软件。<br>
<em>计算机系统的组成（理解）</em><br>
采用冯诺依曼体系结构，由运算器、控制器、存储器、输入输出（I/O）设备五大部件组成。<br>
<em>操作系统与计算机系统（理解）</em><br>
计算机系统由软件、硬件和数据三部分组成，操作系统是配置在计算机硬件上的第一层软件。</p>
<h2 id="12-操作系统的发展过程理解">1.2 操作系统的发展过程（理解）</h2>
<p>简单计算机系统（无操作系统）：用户独占操作系统、<br>
单道批处理系统：自动性、顺序性和单道性（内存中只允许一道程序）、<br>
多道批处理系统：交替执行<img src="https://lyhlyhaa.github.io/post-images/1596942394126.png" alt="" loading="lazy"><br>
宏观并行，微观串行，多道性<br>
分时系统：交互性、及时性、独立性、多路性<br>
<strong>批处理系统、分时系统的出现标志着操作系统的形成</strong><br>
实时系统：及时性、交互性、独立性、多路性和高可靠性</p>
<h2 id="13-操作系统的主要功能掌握">1.3 操作系统的主要功能（掌握）</h2>
<p>处理机管理：进程控制、进程同步、进程通信和进程调度<br>
存储器管理：内存分配、内存保护、地址映射、内存扩充<br>
设备管理：缓冲区管理、设备分配、设备处理、虚拟设备管理<br>
文件管理：<br>
及用户接口：命令接口、程序接口、图形接口</p>
<h1 id="第2章-中断">第2章 中断</h1>
<h2 id="21-中断的基本概念理解">2.1 中断的基本概念（理解）</h2>
<p>目态（用户态，权限低） 管态（核心态）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597117788357.png" alt="" loading="lazy"><br>
中断的作用、中断类型、中断嵌套、中断优先级和中断屏蔽<br>
中断寄存器（每个中断源都有，中断发生时的相关信息记录在该存储器中）、<br>
程序状态字（PSW）：</p>
<h2 id="22-中断在操作系统中的地位了解">2.2 中断在操作系统中的地位（了解）</h2>
<p>中断是多道程序并发执行的推动力<br>
操作系统是由中断驱动的</p>
<h2 id="23-中断响应过程理解">2.3 中断响应过程（理解）</h2>
<h2 id="24-中断处理过程掌握">2.4 中断处理过程（掌握）</h2>
<p>中断处理流程、中断服务程序</p>
<h2 id="25-向量中断了解">2.5 向量中断（了解）</h2>
<h1 id="第3章-进程描述和控制">第3章 进程描述和控制</h1>
<h2 id="31-进程概述">3.1 进程概述</h2>
<p>程序的顺序执行及其特征（理解）<br>
程序的并发执行及其特征（理解）<br>
进程的概念及其特征（掌握）<br>
<strong>动态性</strong><br>
进程状态（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597134258032.png" alt="" loading="lazy"><br>
进程控制块（理解）PCB<br>
PCB是进程的唯一标识符</p>
<h2 id="32-进程控制理解">3.2 进程控制（理解）</h2>
<p>进程创建和终止<br>
进程阻塞和唤醒<br>
进程挂起和激活<br>
<img src="https://lyhlyhaa.github.io/post-images/1597136342534.png" alt="" loading="lazy"></p>
<h2 id="33-线程">3.3 线程</h2>
<p><em>线程简介（理解）</em><br>
线程是基本的cpu执行单元，调度和分派的基本单位，程序执行流的最小单位<br>
进程是资源分配的基本单位<br>
<em>多线程（掌握）</em><br>
线程实现与线程模型（理解）<br>
多对一；一对一；多对多<br>
<img src="https://lyhlyhaa.github.io/post-images/1597286385098.png" alt="" loading="lazy"><br>
<strong>注意：一对一优缺点反了</strong></p>
<h2 id="34-互斥和同步">3.4 互斥和同步</h2>
<p>并发原理：临界资源、临界区等多种术语（掌握）<br>
互斥：多个进程因争用临界区内的共享资源而互斥的执行，即当一个进程在临界区访问共享资源时，其它进程不能进入该临界区访问任何共享资源。<br>
同步：系统中有一些相互合作、协同工作的进程，它们之间的相互联系称为进程的同步。<br>
临界区：是一段程序代码，进程将在此代码中访问共享的资源，当另一个进程已经在该代码中运行时，则该进程不能在这段代码中执行。<br>
临界资源：多个进程间采取互斥的方式实现对临界资源的共享访问。<br>
死锁：两个或两个以上的进程因其中的每个进程都在等待其它进程执行完毕而不能继续执行，这样的情形称为死锁。<br>
饥饿：是指一个可运行的进程虽然能继续执行，但被调度程序无限期的忽视而不能执行的情况 。</p>
<p>硬件同步（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597289851472.png" alt="" loading="lazy"><br>
信号量机制（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597307073833.png" alt="" loading="lazy"><br>
管程机制（理解）</p>
<p>三个经典的进程同步问题（掌握）<br>
生产者-消费者（get） 读者-写者（我裂开了）哲学家就餐问题</p>
<p>消息传递（理解）</p>
<h1 id="第4章-调度与死锁">第4章 调度与死锁</h1>
<figure data-type="image" tabindex="1"><img src="https://lyhlyhaa.github.io/post-images/1597285417811.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计网-网络层]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-wang-wang-luo-ceng/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-wang-wang-luo-ceng/">
        </link>
        <updated>2020-07-31T02:59:17.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1286 比赛]]></title>
        <id>https://lyhlyhaa.github.io/post/1286-bi-sai/</id>
        <link href="https://lyhlyhaa.github.io/post/1286-bi-sai/">
        </link>
        <updated>2020-07-30T08:24:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>有n名选手参加比赛，从1∼n编号。每场比赛由两位选手对决，失败的被淘汰。为了增加比赛的观赏性，举办方并不想比赛双方实力相差太大的，所以决定，每场比赛的两位选手，之前胜场次数之差不能超过1。同时，鸡贼的举办方又不想冠军选手比赛太少了（严重影响比赛收入），希望冠军选手比赛场次越多越好。作为选手的你，当然不希望夺冠路上比赛场次太多，请问在这个赛制下，冠军最多比赛多少场？</p>
<h2 id="输入">输入</h2>
<p>存在不超过10000组样例。每行一个整数n(1≤n≤1018)。</p>
<h2 id="输出">输出</h2>
<p>每行输出一个样例的结果，为一个整数。</p>
<h2 id="样例输入">样例输入</h2>
<p>1<br>
2<br>
3<br>
10<br>
1000000000000000000</p>
<h2 id="样例输出">样例输出</h2>
<p>0<br>
1<br>
2<br>
4<br>
85</p>
<hr>
<p>全部比赛看作一棵树<br>
<img src="https://lyhlyhaa.github.io/post-images/1596097884622.jpg" alt="" loading="lazy"><br>
n 很容易看出来是一个斐波那契数列，之后设置一个数组记录，很容易就完成了<br>
g(1)=1   g(2)=2<br>
g(h)=g(h-1)+g(h-2)<br>
<img src="https://lyhlyhaa.github.io/post-images/1596098127037.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计网-链路层]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-wang-lian-lu-ceng/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-wang-lian-lu-ceng/">
        </link>
        <updated>2020-07-29T02:41:35.000Z</updated>
        <content type="html"><![CDATA[<p>作业三</p>
<ol>
<li>要发送的数据为101110。采用CRC的生成 多项式是P（X）＝X3＋1。试求应添加在数据后面的余数<br>
解：<br>
被除数为101110000，除数为1001，得到余数为011。<br>
<strong>CRC校验码</strong><br>
在发送端，先把数据划分为组。假定每组 k 个比特。<br>
假设待传送的一组数据 M = 101001（现在 k = 6）。我们在数据M 的后面再添加供差错检测用的 n 位冗余码一起发送。<br>
用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。<br>
得到的 (k + n) 位的新数Mx除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少1 位，即 R 是 n 位,为冗余码。<br>
*注意：在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence) *<br>
<img src="https://lyhlyhaa.github.io/post-images/1596007436517.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1596007443448.png" alt="" loading="lazy"></li>
</ol>
<hr>
<ol>
<li>PPP协议使用同步传输技术传送比特串 0110111111111100。试问经过零比特填充后变成 怎样的比特串？若接收端收到的PPP帧的数据部 分是0001110111110111110110，问删除发送端加 入的零比特后变成怎样的比特串？<br>
解：<br>
原比特串：011011111  11111 00    填充后：011011111011111000<br>
原比特串：0001110111110111110110    删除后：000111011111 11111 110<br>
<strong>零比特填充</strong>：在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除，还原信息 。<br>
<strong>PPP协议</strong>：全世界使用得最多的数据链路层协议是点对点协议 ，用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。</li>
</ol>
<hr>
<p>3.　 假定1km长的CSMA/CD网络的数据率为 1Gbit/s。设信号在网络上的传播速率为 200000km/s。求能够使用此协议的最短帧长。<br>
解：对于1km电缆，单程传播时间为1/200000=5微秒，来回路程传播时间为10微秒，为了能够按照CSMA/CD工作，最小帧的发射时间不能小于10微秒，以Gb/s速率工作，10微秒可以发送的比特数等于10<em>10<sup>-6/1*10</sup>-9=10000,因此，最短帧是10000位或1250字节长<br>
 <strong>CSMA/CD协议</strong>：载波监听多点接入/碰撞检测  CSMA/CD，“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。<br>
以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。<br>
单程端到端传播时延记为τ<br>
最短有效帧长 ：数据率</em>2τ</p>
<hr>
<ol>
<li>以太网上只有两个站，它们同时发送数据，产生了碰撞。于是按截断二进制指数退避算法进行重传。重传次数记为i，i＝1，2，3，…。 试计算第1次重传失败的概率、第2次重传失败的概率、第3次重传失败的概率，以及一个站成功发送数据之前的平均重传次数I。<br>
解：<br>
将第i次重传成功的概率记为pi。显然第一次重传失败的概率为0.5，第二次重传失败的概率为0.25，第三次重传失败的概率为0.125.平均重传次数I=1.637 <br>
<a href="https://blog.csdn.net/xingchenhy/article/details/72848029">二进制指数类型退避算法 (truncated binary exponential type):</a></li>
</ol>
<hr>
<p>5.　 假定在图3-30中的所有链路的速率仍然为 100Mbit/s，但所有的以太网交换机都换成为 100Mbit/s的集线器。试计算这9台主机和两个服务器产生的总的吞吐量的最大值。为什么<br>
<img src="https://lyhlyhaa.github.io/post-images/1596164216859.jpg" alt="" loading="lazy"><br>
解：<br>
<em>集线器很像一个多接口的转发器，工作在物理层</em><br>
一个网络中无论有多少台服务器和主机，如果全部连接在一个集线器上，那么该网络最大吞吐量 = 集线器最大值。如果接口全部与交换机相连，那么最大吞吐量 = Σ 各链路最大值<br>
吞吐量 = 整个系统 = 100 Mbit</p>
<hr>
<p>补充问答题<br>
家中电脑TCP/IP属性中默认网关是指哪一个端口（在家的拓扑图标出）？怎样查看这个接口的IP地址(查看的步骤）？解：<br>
Windows10中可以打开设置，打开网络与Internet，打开状态，点击查看网络属性，就可以看到该接口的ip地址。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计网-物理层]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-wang-wu-li-ceng/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-wang-wu-li-ceng/">
        </link>
        <updated>2020-07-28T11:44:36.000Z</updated>
        <content type="html"><![CDATA[<p>1.假定某信道受奈氏准则限制的最高码元速率为20000码元/秒。如果采用振幅调制，把码元的振幅划分为16个不同等级来传送，那么可以获得多高的数据率（bit/s）？<br>
解：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>R</mi><mo>∗</mo><mi>L</mi><mi>o</mi><mi>g</mi><mn>2</mn><mi mathvariant="normal">（</mi><mn>16</mn><mi mathvariant="normal">）</mi><mo>=</mo><mn>20000</mn><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>∗</mo><mn>4</mn><mo>=</mo><mn>80000</mn><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">C=R*Log2（16）=20000b/s*4=80000b/s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mord">6</span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span></span></p>
<p>最基本的二元制调制方法有以下几种：<br>
调幅(AM)：载波的振幅随基带数字信号而变化。<br>
调频(FM)：载波的频率随基带数字信号而变化。<br>
调相(PM) ：载波的初始相位随基带数字信号而变化。<br>
调制方法就是改变码元携带的比特的信息，码元传输速率一般固定，调制之后，传输比特的速率就上升了</p>
<hr>
<p>2.用香农公式计算一下，假定信道带宽为3100Hz，最大信息传输速率为35kbit/s，那么若想使最大信息传输速率增加60％，问信噪比S/N应增大到多少倍？如果在刚才计算出的基础上将信噪比S/N再增大到10倍，问最大信息速率能否再增加20％？<br>
解：<br>
C=Wlog2(1+S/N)b/s-àSN1=2*（C1/W）-1=2*（35000/3100）-1<br>
SN2=2*（C2/W）-1=2*（1.6<em>C1/w）-1=2</em>（1.6<em>35000/3100）-1<br>
SN2/SN1=100信噪比应增大到约100倍。C3=Wlong2（1+SN3）=Wlog2（1+10</em>SN2）C3/C2=18.5%如果在此基础上将信噪比S/N再增大到10倍，最大信息通率只能再增加18.5%左右</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">香</mi><mi mathvariant="normal">农</mi><mi mathvariant="normal">公</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">：</mi><mi>C</mi><mo>=</mo><mi>W</mi><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>(</mo><mn>1</mn><mo>+</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo>)</mo><mo>(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">香农公式：C = W log2(1+S/N) (bit/s)   
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">香</span><span class="mord cjk_fallback">农</span><span class="mord cjk_fallback">公</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></span></p>
<p>W 为信道的带宽（以 Hz 为单位）<br>
信噪比（dB）：10 log10(S/N) (dB)<br>
S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率</p>
<hr>
<p>3.　假定有一种双绞线的衰减是0.7dB/km（在1kHz时），若容许有20dB的衰减，试问使用这种双绞线的链路的工作距离有多长？如果要使这种双绞线的工作距离增大到100公里，问应当使衰减降低到多少？<br>
解：使用这种双绞线的链路的工作距离为=20/0.7=28.6km   衰减应降低到20/100=0.2db</p>
<hr>
<p>4.共有四个站进行码分多址CDMA通信。四个站的码片序列为：<br>
A：（–1–1–1＋1＋1–1＋1＋1）<br>
B：（–1–1＋1–1＋1＋1＋1–1）<br>
C：（–1＋1–1＋1＋1＋1–1–1）<br>
D：（–1＋1–1–1–1–1＋1–1）<br>
现收到这样的码片序列:（–1＋1–3＋1–1–3＋1＋1）。问哪个站发送数据了？发送数据的站发送的是1还是0？<br>
解：<br>
S•A=（＋1－1＋3＋1－1＋3＋1＋1）／8=1，A发送1<br>
S•B=（＋1－1－3－1－1－3＋1－1）／8=－1，B发送0<br>
S•C=（＋1＋1＋3＋1－1－3－1－1）／8=0，C无发送<br>
S•D=（＋1＋1＋3－1＋1＋3＋1－1）／8=1，D发送1</p>
<p>码片序列：<br>
每个站被指派一个唯一的 m bit 码片序列。<br>
如发送比特 1，则发送自己的 m bit 码片序列。<br>
如发送比特 0，则发送该码片序列的二进制反码<br>
为表示方便，将0写为-1，1写为+1</p>
<p><strong>注意：两个不同站的码片序列正交</strong><br>
不同站的码片向量规格化内积为0<br>
任何一个码片向量和该码片向量自己的规格化内积都是1 。<br>
一个码片向量和该码片反码的向量的规格化内积值是 –1。</p>
<hr>
<p>5.　试比较ADSL、HFC以及FTTx接入技术的优缺点。解：<br>
ADSL技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。成本低，易实现，但带宽和质量差异性大。HFC网的最大的优点具有很宽的频带，并且能够利用已经有相当大的覆盖面的有线电视网。要将现有的450MHz单向传输的有线电视网络改造为750MHz双向传输的HFC网需要相当的资金和时间。FTTx（光纤到……）这里字母x可代表不同意思。可提供最好的带宽和质量、但现阶段线路和工程成本太大。</p>
<p>补充问答题1、怎样更改自己电脑的MAC地址（用文字描述操作步骤）解：</p>
<p>打开设备管理器<br>
右键点击适配器。从菜单中点击属性来打开网络适配器的属性窗口。<br>
点击高级选项卡。找到“网络地址”或“本地管理地址”条目。点击该条目，将在右侧看到“值”（Value）的字样和输入框。点击单选按钮来启用“值”（Value）的输入框。<br>
输入新的MAC地址。MAC地址的格式是，不包含破折号和冒号的12位数值。<br>
重启计算机来启用变更。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小生成树]]></title>
        <id>https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/">
        </link>
        <updated>2020-07-26T07:00:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="克鲁斯卡尔算法">克鲁斯卡尔算法：</h1>
<p>1.把边进行排序，按从从小到大的顺序。<br>
2.贪心算法，找未加入通路的权值最小的边<br>
3.判断是否形成环，如果形成，则跳过这一条边，返回第二步，如果没有，则把找到的边加入通路中，返回第二步<br>
4.当通路中的的边的个数等于点的个数-1，则最小生成树已经形成。</p>
<p><em>排序可以用sort函数，边的存储可以用结构体数组</em><br>
<strong>主要是判断是否形成环：</strong><br>
使用<a href="https://blog.csdn.net/qq_41593380/article/details/81146850">并查集</a><br>
<strong>初始化</strong></p>
<pre><code>void init(int n)
{
    for (int i = 1; i &lt;= n; ++i)
        fa[i] = i;
}
</code></pre>
<p><strong>路径压缩查找</strong></p>
<pre><code>int find(int x)
{
    return x == fa[x] ? x : (fa[x] = find(fa[x]));//
}
</code></pre>
<p><strong>合并</strong></p>
<pre><code>ivoid merge(int i, int j)
{
    fa[find(i)] = find(j);
}//合并
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐波拉契数列]]></title>
        <id>https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/</id>
        <link href="https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/">
        </link>
        <updated>2020-07-24T07:30:17.000Z</updated>
        <content type="html"><![CDATA[<p>。。。。<br>
今晚整理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[骨牌问题（铺地砖）]]></title>
        <id>https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/</id>
        <link href="https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/">
        </link>
        <updated>2020-07-24T07:14:41.000Z</updated>
        <content type="html"><![CDATA[<p>暂时看一下别的博客（https://blog.csdn.net/xiangAccepted/article/details/80229187?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三色旗问题]]></title>
        <id>https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/</id>
        <link href="https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/">
        </link>
        <updated>2020-07-24T02:54:57.000Z</updated>
        <content type="html"><![CDATA[<p>要用到三个指针：一个前指针begin，一个中指针current，一个后指针end，current指针遍历整个数组序列，当</p>
<p>current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ；<br>
current指针所指元素为1时，不做任何交换（即球不动），而后current++ ；<br>
current指针所指元素为2时，与end指针所指的元素交换，而后，current指针不动，end-- 。</p>
]]></content>
    </entry>
</feed>