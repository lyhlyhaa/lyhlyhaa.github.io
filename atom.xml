<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lyhlyhaa.github.io</id>
    <title>混子协会会长</title>
    <updated>2020-08-24T04:15:29.994Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lyhlyhaa.github.io"/>
    <link rel="self" href="https://lyhlyhaa.github.io/atom.xml"/>
    <logo>https://lyhlyhaa.github.io/images/avatar.png</logo>
    <icon>https://lyhlyhaa.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 混子协会会长</rights>
    <entry>
        <title type="html"><![CDATA[逆序数]]></title>
        <id>https://lyhlyhaa.github.io/post/ni-xu-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/ni-xu-shu/">
        </link>
        <updated>2020-08-01T09:15:57.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/dlengong/article/details/7594919?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.channel_param">文章</a><br>
1.两层循环<br>
一猜就会超时，后来试了一下，果然。<br>
2.归并排序<br>
把数组分成两份，分别进行排序，然后合并<br>
会用到递归，从最开始的数组，到整个区间只有一个元素结束，即l==r<br>
<img src="https://lyhlyhaa.github.io/post-images/1596333420953.gif" alt="" loading="lazy"><br>
合并操作：<br>
<img src="https://lyhlyhaa.github.io/post-images/1596333135649.gif" alt="" loading="lazy"><br>
在两个分出来的数组比较完之后，把未填入的数组剩下的数依次（因为数组已经排好序）填入</p>
<pre><code>while(i&lt;=mid) temp[k++] = a[i++];  
while(j&lt;=right) temp[k++] = a[j++];
</code></pre>
<p>用归并求逆序数的关键就在于<br>
Seq1：3  4  5<br>
Seq2：2  6  8  9<br>
合并成一个有序序:</p>
<p>Seq：2  3  4  5  6  8  9</p>
<p>对于序列seq1中的某个数a[i],序列seq2中的某个数a[j]，如果a[i]&lt;a[j],没有逆序数，如果a[i]&gt;a[j]，那么逆序数为seq1中a[i]后边元素的个数(包括a[i])，即len1-i+1,<br>
3.<a href="http://www.cppblog.com/Ylemzy/articles/98322.html">树状数组</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统]]></title>
        <id>https://lyhlyhaa.github.io/post/cao-zuo-xi-tong/</id>
        <link href="https://lyhlyhaa.github.io/post/cao-zuo-xi-tong/">
        </link>
        <updated>2020-08-01T02:21:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第1章-操作系统概述">第1章 操作系统概述</h1>
<h2 id="11-什么是操作系统">1.1 什么是操作系统</h2>
<p><em>操作系统的定义（掌握）</em><br>
操作系统是计算机系统中最基础，最重要的<strong>系统软件</strong>，是其他软件的支撑软件。<br>
<em>计算机系统的组成（理解）</em><br>
采用冯诺依曼体系结构，由运算器、控制器、存储器、输入输出（I/O）设备五大部件组成。<br>
<em>操作系统与计算机系统（理解）</em><br>
计算机系统由软件、硬件和数据三部分组成，操作系统是配置在计算机硬件上的第一层软件。</p>
<h2 id="12-操作系统的发展过程理解">1.2 操作系统的发展过程（理解）</h2>
<p>简单计算机系统（无操作系统）：用户独占操作系统、<br>
单道批处理系统：自动性、顺序性和单道性（内存中只允许一道程序）、<br>
多道批处理系统：交替执行<img src="https://lyhlyhaa.github.io/post-images/1596942394126.png" alt="" loading="lazy"><br>
宏观并行，微观串行，多道性<br>
分时系统：交互性、及时性、独立性、多路性<br>
<strong>批处理系统、分时系统的出现标志着操作系统的形成</strong><br>
实时系统：及时性、交互性、独立性、多路性和高可靠性</p>
<h2 id="并行是指两个或者多个事件在同一时刻发生而并发是指两个或多个事件在同一时间间隔内发生-13-操作系统的主要功能掌握"><strong>并行是指两个或者多个事件在同一时刻发生;而并发是指两个或多个事件在同一时间间隔内发生。</strong>*<br>
1.3 操作系统的主要功能（掌握）</h2>
<p>处理机管理：进程控制、进程同步、进程通信和进程调度<br>
存储器管理：内存分配、内存保护、地址映射、内存扩充<br>
设备管理：缓冲区管理、设备分配、设备处理、虚拟设备管理<br>
文件管理：<br>
及用户接口：命令接口、程序接口、图形接口</p>
<h1 id="第2章-中断">第2章 中断</h1>
<h2 id="21-中断的基本概念理解">2.1 中断的基本概念（理解）</h2>
<p>目态（用户态，权限低） 管态（核心态）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597117788357.png" alt="" loading="lazy"><br>
中断的作用、中断类型、中断嵌套、中断优先级和中断屏蔽<br>
中断寄存器（每个中断源都有，中断发生时的相关信息记录在该存储器中）、<br>
程序状态字（PSW）：</p>
<h2 id="22-中断在操作系统中的地位了解">2.2 中断在操作系统中的地位（了解）</h2>
<p>中断是多道程序并发执行的推动力<br>
操作系统是由中断驱动的</p>
<h2 id="23-中断响应过程理解">2.3 中断响应过程（理解）</h2>
<h2 id="24-中断处理过程掌握">2.4 中断处理过程（掌握）</h2>
<p>中断处理流程、中断服务程序</p>
<h2 id="25-向量中断了解">2.5 向量中断（了解）</h2>
<h1 id="第3章-进程描述和控制">第3章 进程描述和控制</h1>
<h2 id="31-进程概述">3.1 进程概述</h2>
<p>程序的顺序执行及其特征（理解）<br>
程序的并发执行及其特征（理解）<br>
进程的概念及其特征（掌握）<br>
程序是完成特定任务的一组指令的结合，可以永久保存，具有静态性；<br>
进程是程序在某一数据结构上的一次执行过程，是系统进行资源分配和调度的基本单位，具有动态性；<br>
一个进程可以包含多个程序，一个程序也可以被多个进程执行。</p>
<p><strong>动态性</strong><br>
进程状态（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597134258032.png" alt="" loading="lazy"><br>
进程控制块（理解）PCB<br>
PCB是进程的唯一标识符</p>
<h2 id="32-进程控制理解">3.2 进程控制（理解）</h2>
<p>进程创建和终止<br>
进程阻塞和唤醒<br>
进程挂起和激活<br>
<img src="https://lyhlyhaa.github.io/post-images/1597136342534.png" alt="" loading="lazy"></p>
<h2 id="33-线程">3.3 线程</h2>
<p><em>线程简介（理解）</em><br>
线程是基本的cpu执行单元，调度和分派的基本单位，程序执行流的最小单位<br>
进程是资源分配的基本单位<br>
<em>多线程（掌握）</em><br>
线程实现与线程模型（理解）<br>
多对一；一对一；多对多<br>
<img src="https://lyhlyhaa.github.io/post-images/1597286385098.png" alt="" loading="lazy"><br>
<strong>注意：一对一优缺点反了</strong></p>
<h2 id="34-互斥和同步">3.4 互斥和同步</h2>
<p>并发原理：临界资源、临界区等多种术语（掌握）<br>
互斥：多个进程因争用临界区内的共享资源而互斥的执行，即当一个进程在临界区访问共享资源时，其它进程不能进入该临界区访问任何共享资源。<br>
同步：系统中有一些相互合作、协同工作的进程，它们之间的相互联系称为进程的同步。<br>
临界区：是一段程序代码，进程将在此代码中访问共享的资源，当另一个进程已经在该代码中运行时，则该进程不能在这段代码中执行。<br>
临界资源：多个进程间采取互斥的方式实现对临界资源的共享访问。<br>
死锁：两个或两个以上的进程因其中的每个进程都在等待其它进程执行完毕而不能继续执行，这样的情形称为死锁。<br>
饥饿：是指一个可运行的进程虽然能继续执行，但被调度程序无限期的忽视而不能执行的情况 。</p>
<p>硬件同步（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597289851472.png" alt="" loading="lazy"><br>
信号量机制（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597307073833.png" alt="" loading="lazy"><br>
管程机制（理解）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597457450240.png" alt="" loading="lazy"><br>
三个经典的进程同步问题（掌握）<br>
生产者-消费者（get） 注意：当缓冲区已满，即empty为0，full为n，若mutex的p操作在前，则会死锁<br>
读者-写者（我裂开了）当一个进程允许并发，和别的互斥，设置整型信号量记录同时运行的进程，并且要设置一个记录型信号量来让这个整型信号量互斥访问<br>
哲学家就餐问题 主要解决死锁问题，（信息量数组）</p>
<p>消息传递（理解）</p>
<h1 id="第4章-调度与死锁">第4章 调度与死锁</h1>
<h2 id="41调度简介理解">4.1调度简介（理解）</h2>
<h2 id="调度的基本概念-调度原则调度原则42-调度算法掌握">调度的基本概念、调度原则<br>
<img src="https://lyhlyhaa.github.io/post-images/1597285417811.png" alt="" loading="lazy"><br>
调度原则：<img src="https://lyhlyhaa.github.io/post-images/1597544207270.png" alt="" loading="lazy"><br>
4.2 调度算法（掌握）</h2>
<p>先来先服务：按进入队列的先后顺序（以等待时间来）<br>
短作业优先：当前已到达的运行时间最短的优先（以服务时间）<br>
最高响应比优先：<br>
<code>响应比：（等待时间+服务时间）/服务时间</code><br>
以上多用于早期的批处理系统中<br>
优先级：每个作业（进程）有各自的优先级，调度时选择优先级最高的进程<br>
<code>有抢占式和非抢占式，会发生饥饿、实时系统</code><br>
时间片轮转：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。(不会饥饿，分时系统)<br>
多级反馈队列（有点复杂，就不写了）：<br>
实时调度：</p>
<h2 id="43-死锁简介">4.3 死锁简介</h2>
<p>资源（理解）<br>
在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推<br>
进的现象，就是“死锁”发生死锁后若无外力干涉，这些进程都将无法向前推进。</p>
<p>死锁产生的原因和必要条件（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597567271816.png" alt="" loading="lazy"><br>
原因：对系统资源的竞争、程序推进顺序不合法、信号量使用不当</p>
<p>死锁的表示方法和判定（理解）<br>
系统资源分配图，请求边、分配边，进程节点和资源节点</p>
<h2 id="44-死锁预防理解">4.4 死锁预防（理解）</h2>
<p>破坏“请求和保持”条件<br>
破坏“不剥夺“条件<br>
破坏”循环等待“条件<br>
破坏”互斥访问“条件（一般不用）</p>
<h2 id="45-死锁避免掌握">4.5 死锁避免（掌握）</h2>
<p>安全状态：存在安全序列就ok，死锁一定是不安全状态、不安全状态不一定死锁<br>
银行家算法数据结构、流程<br>
安全性算法</p>
<h2 id="46-死锁检测和恢复理解">4.6 死锁检测和恢复（理解）</h2>
<p>解除死锁：<br>
1.资源剥夺法<br>
2.撤销进程法<br>
2.进程回退法</p>
<h1 id="第5章-内存管理">第5章 内存管理</h1>
<h2 id="51-概述理解">5.1 概述（理解）</h2>
<p>存储层次结构<br>
存储管理的目的和任务：1.内存分配 2.地址映射 3.内存共享与保护 4.内存扩充</p>
<h2 id="52-地址重定位理解">5.2 地址重定位（理解）</h2>
<p>重定位的基本概念：因为逻辑地址与物理地址不一样<br>
静态重定位：在程序执行之前<br>
动态重定位：在程序执行过程中，需要重定位寄存器<br>
补充：程序的装入、程序的链接</p>
<h2 id="53-分区存储管理连续分配">5.3 分区存储管理（连续分配）</h2>
<p>注意：内部碎片：分配给某进程的内存区域中，某些没有用上的部分<br>
外部碎片：内存中某些空闲分区太小难以利用</p>
<p>单一连续：任何时刻内存中只能能有一道用户程序<br>
固定分区、可变分区分配（理解）</p>
<p>分区分配算法（掌握）<br>
首次适应算法：从低地址开始查找，找到第一个能满足大小的空闲分区<br>
最佳适应算法：<br>
最坏适应算法：<br>
循环首次适应算法：<br>
补充：哈希算法、伙伴系统（理解）</p>
<h2 id="54-页式存储管理非连续分配">5.4 页式存储管理（非连续分配）</h2>
<p>页：把用户进程的地址空间分为与物理块大小相等的一个个区域，称为页或页面<br>
页号=逻辑地址/页面长度(取除法的整数部分)<br>
页内偏移量=逻辑地址%页面长度(取除法的余数部分)<br>
<img src="https://lyhlyhaa.github.io/post-images/1597756802838.png" alt="" loading="lazy"><br>
块：内存等分称为块<br>
页表（每一个进程有自己的页表）、地址结构、</p>
<p>分页地址变换、<img src="https://lyhlyhaa.github.io/post-images/1597755784851.png" alt="" loading="lazy"><br>
页表长度表示有多少个页<br>
<em><strong>页表项是指页表中的一行？</strong></em><br>
快表（掌握）考察访问时间</p>
<p>两级页表、多级页表（理解）</p>
<h2 id="55-段式与段页式存储管理">5.5 段式与段页式存储管理</h2>
<p>段、段表、地址结构、分段地址变换（掌握）<br>
段的逻辑地址由段号和段内地址所组成。<br>
每个段在表中占有一个表项，其中记录了该段在内存中的起始地址（基址）和段的长度（段长）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597980322934.png" alt="" loading="lazy"><br>
分页和分段的区别（掌握）<br>
(1) 页是信息的物理单位，仅仅是出于系统管理的需要；段是信息的逻辑单位，其目的是满足用户的需要。<br>
(2) 页的大小固定且由系统确定，一个系统只能有一种大小的页面；段的长度不固定，决定于用户所编写的程序；<br>
(3) 分页的作业地址空间是一维的；分段的作业地址空间是二维的。<br>
(4) 通常分段的段内空间会比分页的页面空间大，因此段表会比页表短。</p>
<p>段页式存储管理（理解）</p>
<h2 id="56-内存扩充技术了解">5.6 内存扩充技术（了解）</h2>
<p>覆盖、交换</p>
<h2 id="57-虚拟存储管理">5.7 虚拟存储管理</h2>
<p>基本原理：局部性原理、虚拟存储器（理解）<br>
(1) 时间局限性。程序中的某条指令被执行，不久后会再次执行；某个数据被访问，不久后将再次被访问。产生时间局限性的典型原因是在程序中存在着大量的循环操作。<br>
(2) 空间局限性。 程序访问了某个存储单元，不久后，其附近的存储单元也将被访问。</p>
<p>请求分页存储管理（理解）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597822969611.png" alt="" loading="lazy"><br>
页面置换算法：<br>
最佳置换：每次选择淘汰的页面将是以后永不使用，或者再最长时间内不再被访问的页面，这样可以保证最低的缺页率。（无法实现，用来衡量算法好坏）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597826381870.png" alt="" loading="lazy"><br>
先进先出置换算法（FIFO）：每次淘汰的页面是最早进入内存的页面，可能有beledy异常<br>
最近最久未使用置换算法（LRU）：每次淘汰的页面时最近最久未使用的页面（逆向扫描😕，实现开销比较大，性能好）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597825736996.png" alt="" loading="lazy"><br>
时钟置换算法（CLOCK）：<br>
第二次机会（NRU），就是第二个：<br>
请求分页存储管理系统性能分析：缺页率、抖动、页面大小（理解）<br>
缺页率：缺页中断次数/总次数；<br>
抖动：如此频繁地更换页面，以至一个进程在运行中，将把大部分时间花在完成页面置换的工作上，我们称该进程发生了“抖动”。抖动现象分为局部抖动和全局抖动两种类型。</p>
<p>请求分段存储管理（理解）</p>
<h1 id="第6章-设备管理">第6章 设备管理</h1>
<h2 id="61-概述理解">6.1 概述（理解）</h2>
<p>设备管理的的目标和任务<br>
I/O系统结构：<br>
I/O设备分为机械部件和电子部件（I/O控制器，一个可以控制多个设备）<br>
I/O设备分类</p>
<h2 id="62-io系统控制方式掌握">6.2 I/O系统控制方式（掌握）</h2>
<p>程序直接控制方式<br>
中断控制方式<img src="https://lyhlyhaa.github.io/post-images/1597894847490.png" alt="" loading="lazy"><br>
DMA控制方式<img src="https://lyhlyhaa.github.io/post-images/1597895507112.png" alt="" loading="lazy"><br>
通道控制方式<img src="https://lyhlyhaa.github.io/post-images/1597895746989.png" alt="" loading="lazy"></p>
<h2 id="63-io软件的组成">6.3 I/O软件的组成</h2>
<p>I/O软件设计目标和原则（理解）<br>
I/O软件结构（理解）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597910317722.png" alt="" loading="lazy"><br>
设备驱动程序（了解）<br>
I/O设备的控制方式（掌握）<br>
设备无关软件（了解）<br>
用户层软件：<br>
SPOOLing技术（假脱机技术）的引入、组成和特点（理解）<br>
所谓脱机就是脱离主机控制的输入输出<br>
<img src="https://lyhlyhaa.github.io/post-images/1597911772456.png" alt="" loading="lazy"></p>
<h2 id="64-具有通道的设备管理">6.4 具有通道的设备管理</h2>
<p>通道类型（掌握）</p>
<h2 id="65-设备管理相关技术">6.5 设备管理相关技术</h2>
<p>DMA（理解）<br>
缓冲技术：<br>
缓存区作用：<br>
（1）可以改善CPU与I/O设备间速度不匹配的矛盾。<br>
（2）可以减少对 CPU的中断频率，放宽对中断响应时间的限制。<br>
（3）可以提高 CPU和 I/O设备之间的并行性。<br>
<img src="https://lyhlyhaa.github.io/post-images/1597913868957.png" alt="" loading="lazy"><br>
单缓冲（一个缓冲区）、双缓冲（两个缓冲）、循环缓冲区和缓冲池（理解）</p>
<p>总线技术（不考）</p>
<h2 id="66-磁盘存储管理">6.6 磁盘存储管理</h2>
<p>磁盘简述：磁盘的定义、组成、磁盘访问时间（理解）<br>
磁盘调度：FCFS、SSTF、SCAN、C-SCAN、N步扫描、F-SCAN（掌握）<br>
磁盘管理（不考）<br>
容错技术：容错技术的概念、廉价磁盘冗余阵列（理解）</p>
<h1 id="第7章-文件管理">第7章 文件管理</h1>
<p>7.1 概述（理解）<br>
文件、文件系统的定义<br>
7.2 文件结构<br>
逻辑结构（理解）<br>
索引文件，<img src="https://lyhlyhaa.github.io/post-images/1597930086320.png" alt="" loading="lazy"><br>
物理结构：顺序结构、链接结构、索引结构（掌握）；<br>
直接文件、哈希文件（理解）<br>
7.3 文件目录<br>
文件控制块FCB（掌握）<br>
为了实现按名存取，一个文件对应一个FCB，一个FCB就是一个目录项，多个FCB组成文件目录<br>
索引节点（掌握）：把文件控制块中除了文件名之外的文件描述信息放到一个索引结点指针中，加快了文件检索速度<br>
目录结构：单级（只有一个目录表）、两级（两个）和多级（多个）（了解）<br>
目录查询（了解）<br>
绝对路径：从根目录出发 相对路径：从当前目录出发<br>
7.4 文件共享和安全（理解）<br>
文件共享：符号链接实现共享、索引节点实现共享（理解）<br>
文件安全：存取控制矩阵、存取控制表、用户权限表、口令方法（了解）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1286 比赛]]></title>
        <id>https://lyhlyhaa.github.io/post/1286-bi-sai/</id>
        <link href="https://lyhlyhaa.github.io/post/1286-bi-sai/">
        </link>
        <updated>2020-07-30T08:24:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>有n名选手参加比赛，从1∼n编号。每场比赛由两位选手对决，失败的被淘汰。为了增加比赛的观赏性，举办方并不想比赛双方实力相差太大的，所以决定，每场比赛的两位选手，之前胜场次数之差不能超过1。同时，鸡贼的举办方又不想冠军选手比赛太少了（严重影响比赛收入），希望冠军选手比赛场次越多越好。作为选手的你，当然不希望夺冠路上比赛场次太多，请问在这个赛制下，冠军最多比赛多少场？</p>
<h2 id="输入">输入</h2>
<p>存在不超过10000组样例。每行一个整数n(1≤n≤1018)。</p>
<h2 id="输出">输出</h2>
<p>每行输出一个样例的结果，为一个整数。</p>
<h2 id="样例输入">样例输入</h2>
<p>1<br>
2<br>
3<br>
10<br>
1000000000000000000</p>
<h2 id="样例输出">样例输出</h2>
<p>0<br>
1<br>
2<br>
4<br>
85</p>
<hr>
<p>全部比赛看作一棵树<br>
<img src="https://lyhlyhaa.github.io/post-images/1596097884622.jpg" alt="" loading="lazy"><br>
n 很容易看出来是一个斐波那契数列，之后设置一个数组记录，很容易就完成了<br>
g(1)=1   g(2)=2<br>
g(h)=g(h-1)+g(h-2)<br>
<img src="https://lyhlyhaa.github.io/post-images/1596098127037.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计网-链路层]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-wang-lian-lu-ceng/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-wang-lian-lu-ceng/">
        </link>
        <updated>2020-07-29T02:41:35.000Z</updated>
        <content type="html"><![CDATA[<p>作业三</p>
<ol>
<li>要发送的数据为101110。采用CRC的生成 多项式是P（X）＝X3＋1。试求应添加在数据后面的余数<br>
解：<br>
被除数为101110000，除数为1001，得到余数为011。<br>
<strong>CRC校验码</strong><br>
在发送端，先把数据划分为组。假定每组 k 个比特。<br>
假设待传送的一组数据 M = 101001（现在 k = 6）。我们在数据M 的后面再添加供差错检测用的 n 位冗余码一起发送。<br>
用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。<br>
得到的 (k + n) 位的新数Mx除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少1 位，即 R 是 n 位,为冗余码。<br>
*注意：在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence) *<br>
<img src="https://lyhlyhaa.github.io/post-images/1596007436517.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1596007443448.png" alt="" loading="lazy"></li>
</ol>
<hr>
<ol>
<li>PPP协议使用同步传输技术传送比特串 0110111111111100。试问经过零比特填充后变成 怎样的比特串？若接收端收到的PPP帧的数据部 分是0001110111110111110110，问删除发送端加 入的零比特后变成怎样的比特串？<br>
解：<br>
原比特串：011011111  11111 00    填充后：011011111011111000<br>
原比特串：0001110111110111110110    删除后：000111011111 11111 110<br>
<strong>零比特填充</strong>：在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除，还原信息 。<br>
<strong>PPP协议</strong>：全世界使用得最多的数据链路层协议是点对点协议 ，用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。</li>
</ol>
<hr>
<p>3.　 假定1km长的CSMA/CD网络的数据率为 1Gbit/s。设信号在网络上的传播速率为 200000km/s。求能够使用此协议的最短帧长。<br>
解：对于1km电缆，单程传播时间为1/200000=5微秒，来回路程传播时间为10微秒，为了能够按照CSMA/CD工作，最小帧的发射时间不能小于10微秒，以Gb/s速率工作，10微秒可以发送的比特数等于10<em>10<sup>-6/1*10</sup>-9=10000,因此，最短帧是10000位或1250字节长<br>
 <strong>CSMA/CD协议</strong>：载波监听多点接入/碰撞检测  CSMA/CD，“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。<br>
以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。<br>
单程端到端传播时延记为τ<br>
最短有效帧长 ：数据率</em>2τ</p>
<hr>
<ol>
<li>以太网上只有两个站，它们同时发送数据，产生了碰撞。于是按截断二进制指数退避算法进行重传。重传次数记为i，i＝1，2，3，…。 试计算第1次重传失败的概率、第2次重传失败的概率、第3次重传失败的概率，以及一个站成功发送数据之前的平均重传次数I。<br>
解：<br>
将第i次重传成功的概率记为pi。显然第一次重传失败的概率为0.5，第二次重传失败的概率为0.25，第三次重传失败的概率为0.125.平均重传次数I=1.637 <br>
<a href="https://blog.csdn.net/xingchenhy/article/details/72848029">二进制指数类型退避算法 (truncated binary exponential type):</a></li>
</ol>
<hr>
<p>5.　 假定在图3-30中的所有链路的速率仍然为 100Mbit/s，但所有的以太网交换机都换成为 100Mbit/s的集线器。试计算这9台主机和两个服务器产生的总的吞吐量的最大值。为什么<br>
<img src="https://lyhlyhaa.github.io/post-images/1596164216859.jpg" alt="" loading="lazy"><br>
解：<br>
<em>集线器很像一个多接口的转发器，工作在物理层</em><br>
一个网络中无论有多少台服务器和主机，如果全部连接在一个集线器上，那么该网络最大吞吐量 = 集线器最大值。如果接口全部与交换机相连，那么最大吞吐量 = Σ 各链路最大值<br>
吞吐量 = 整个系统 = 100 Mbit</p>
<hr>
<p>补充问答题<br>
家中电脑TCP/IP属性中默认网关是指哪一个端口（在家的拓扑图标出）？怎样查看这个接口的IP地址(查看的步骤）？解：<br>
Windows10中可以打开设置，打开网络与Internet，打开状态，点击查看网络属性，就可以看到该接口的ip地址。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计网-物理层]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-wang-wu-li-ceng/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-wang-wu-li-ceng/">
        </link>
        <updated>2020-07-28T11:44:36.000Z</updated>
        <content type="html"><![CDATA[<p>1.假定某信道受奈氏准则限制的最高码元速率为20000码元/秒。如果采用振幅调制，把码元的振幅划分为16个不同等级来传送，那么可以获得多高的数据率（bit/s）？<br>
解：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>R</mi><mo>∗</mo><mi>L</mi><mi>o</mi><mi>g</mi><mn>2</mn><mi mathvariant="normal">（</mi><mn>16</mn><mi mathvariant="normal">）</mi><mo>=</mo><mn>20000</mn><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>∗</mo><mn>4</mn><mo>=</mo><mn>80000</mn><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">C=R*Log2（16）=20000b/s*4=80000b/s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mord">6</span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span></span></p>
<p>最基本的二元制调制方法有以下几种：<br>
调幅(AM)：载波的振幅随基带数字信号而变化。<br>
调频(FM)：载波的频率随基带数字信号而变化。<br>
调相(PM) ：载波的初始相位随基带数字信号而变化。<br>
调制方法就是改变码元携带的比特的信息，码元传输速率一般固定，调制之后，传输比特的速率就上升了</p>
<hr>
<p>2.用香农公式计算一下，假定信道带宽为3100Hz，最大信息传输速率为35kbit/s，那么若想使最大信息传输速率增加60％，问信噪比S/N应增大到多少倍？如果在刚才计算出的基础上将信噪比S/N再增大到10倍，问最大信息速率能否再增加20％？<br>
解：<br>
C=Wlog2(1+S/N)b/s-àSN1=2*（C1/W）-1=2*（35000/3100）-1<br>
SN2=2*（C2/W）-1=2*（1.6<em>C1/w）-1=2</em>（1.6<em>35000/3100）-1<br>
SN2/SN1=100信噪比应增大到约100倍。C3=Wlong2（1+SN3）=Wlog2（1+10</em>SN2）C3/C2=18.5%如果在此基础上将信噪比S/N再增大到10倍，最大信息通率只能再增加18.5%左右</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">香</mi><mi mathvariant="normal">农</mi><mi mathvariant="normal">公</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">：</mi><mi>C</mi><mo>=</mo><mi>W</mi><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>(</mo><mn>1</mn><mo>+</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo>)</mo><mo>(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">香农公式：C = W log2(1+S/N) (bit/s)   
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">香</span><span class="mord cjk_fallback">农</span><span class="mord cjk_fallback">公</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></span></p>
<p>W 为信道的带宽（以 Hz 为单位）<br>
信噪比（dB）：10 log10(S/N) (dB)<br>
S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率</p>
<hr>
<p>3.　假定有一种双绞线的衰减是0.7dB/km（在1kHz时），若容许有20dB的衰减，试问使用这种双绞线的链路的工作距离有多长？如果要使这种双绞线的工作距离增大到100公里，问应当使衰减降低到多少？<br>
解：使用这种双绞线的链路的工作距离为=20/0.7=28.6km   衰减应降低到20/100=0.2db</p>
<hr>
<p>4.共有四个站进行码分多址CDMA通信。四个站的码片序列为：<br>
A：（–1–1–1＋1＋1–1＋1＋1）<br>
B：（–1–1＋1–1＋1＋1＋1–1）<br>
C：（–1＋1–1＋1＋1＋1–1–1）<br>
D：（–1＋1–1–1–1–1＋1–1）<br>
现收到这样的码片序列:（–1＋1–3＋1–1–3＋1＋1）。问哪个站发送数据了？发送数据的站发送的是1还是0？<br>
解：<br>
S•A=（＋1－1＋3＋1－1＋3＋1＋1）／8=1，A发送1<br>
S•B=（＋1－1－3－1－1－3＋1－1）／8=－1，B发送0<br>
S•C=（＋1＋1＋3＋1－1－3－1－1）／8=0，C无发送<br>
S•D=（＋1＋1＋3－1＋1＋3＋1－1）／8=1，D发送1</p>
<p>码片序列：<br>
每个站被指派一个唯一的 m bit 码片序列。<br>
如发送比特 1，则发送自己的 m bit 码片序列。<br>
如发送比特 0，则发送该码片序列的二进制反码<br>
为表示方便，将0写为-1，1写为+1</p>
<p><strong>注意：两个不同站的码片序列正交</strong><br>
不同站的码片向量规格化内积为0<br>
任何一个码片向量和该码片向量自己的规格化内积都是1 。<br>
一个码片向量和该码片反码的向量的规格化内积值是 –1。</p>
<hr>
<p>5.　试比较ADSL、HFC以及FTTx接入技术的优缺点。解：<br>
ADSL技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。成本低，易实现，但带宽和质量差异性大。HFC网的最大的优点具有很宽的频带，并且能够利用已经有相当大的覆盖面的有线电视网。要将现有的450MHz单向传输的有线电视网络改造为750MHz双向传输的HFC网需要相当的资金和时间。FTTx（光纤到……）这里字母x可代表不同意思。可提供最好的带宽和质量、但现阶段线路和工程成本太大。</p>
<p>补充问答题1、怎样更改自己电脑的MAC地址（用文字描述操作步骤）解：</p>
<p>打开设备管理器<br>
右键点击适配器。从菜单中点击属性来打开网络适配器的属性窗口。<br>
点击高级选项卡。找到“网络地址”或“本地管理地址”条目。点击该条目，将在右侧看到“值”（Value）的字样和输入框。点击单选按钮来启用“值”（Value）的输入框。<br>
输入新的MAC地址。MAC地址的格式是，不包含破折号和冒号的12位数值。<br>
重启计算机来启用变更。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小生成树]]></title>
        <id>https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/">
        </link>
        <updated>2020-07-26T07:00:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="克鲁斯卡尔算法">克鲁斯卡尔算法：</h1>
<p>1.把边进行排序，按从从小到大的顺序。<br>
2.贪心算法，找未加入通路的权值最小的边<br>
3.判断是否形成环，如果形成，则跳过这一条边，返回第二步，如果没有，则把找到的边加入通路中，返回第二步<br>
4.当通路中的的边的个数等于点的个数-1，则最小生成树已经形成。</p>
<p><em>排序可以用sort函数，边的存储可以用结构体数组</em><br>
<strong>主要是判断是否形成环：</strong><br>
使用<a href="https://blog.csdn.net/qq_41593380/article/details/81146850">并查集</a><br>
<strong>初始化</strong></p>
<pre><code>void init(int n)
{
    for (int i = 1; i &lt;= n; ++i)
        fa[i] = i;
}
</code></pre>
<p><strong>路径压缩查找</strong></p>
<pre><code>int find(int x)
{
    return x == fa[x] ? x : (fa[x] = find(fa[x]));//
}
</code></pre>
<p><strong>合并</strong></p>
<pre><code>ivoid merge(int i, int j)
{
    fa[find(i)] = find(j);
}//合并
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐波拉契数列]]></title>
        <id>https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/</id>
        <link href="https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/">
        </link>
        <updated>2020-07-24T07:30:17.000Z</updated>
        <content type="html"><![CDATA[<p>。。。。<br>
今晚整理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[骨牌问题（铺地砖）]]></title>
        <id>https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/</id>
        <link href="https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/">
        </link>
        <updated>2020-07-24T07:14:41.000Z</updated>
        <content type="html"><![CDATA[<p>暂时看一下别的博客（https://blog.csdn.net/xiangAccepted/article/details/80229187?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三色旗问题]]></title>
        <id>https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/</id>
        <link href="https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/">
        </link>
        <updated>2020-07-24T02:54:57.000Z</updated>
        <content type="html"><![CDATA[<p>要用到三个指针：一个前指针begin，一个中指针current，一个后指针end，current指针遍历整个数组序列，当</p>
<p>current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ；<br>
current指针所指元素为1时，不做任何交换（即球不动），而后current++ ；<br>
current指针所指元素为2时，与end指针所指的元素交换，而后，current指针不动，end-- 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络（考试）]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-suan-ji-wang-luo/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-suan-ji-wang-luo/">
        </link>
        <updated>2020-07-23T08:31:33.000Z</updated>
        <content type="html"><![CDATA[<p><em>图文无关😂</em></p>
<hr>
<h1 id="概论">概论</h1>
<p>OSI分层<br>
<img src="https://lyhlyhaa.github.io/post-images/1597219135928.png" alt="" loading="lazy"><br>
前四层，端到端；后三层，点到点</p>
<p>五层模型：应用层、传输层、网络层、链路层、物理层</p>
<figure data-type="image" tabindex="1"><img src="https://lyhlyhaa.github.io/post-images/1597239423967.png" alt="" loading="lazy"></figure>
<p>计算机网络的三个组成部分是主机、通信子网和协议</p>
<p>速率：速率即数据率或称数据传输率或比特率（换算时是以10的三次方换算）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597219935014.png" alt="" loading="lazy"></p>
<p>带宽：计算机网络中表示网络的通信线路传送数据的能力（其实指的就是在链路的入口主机发送数据的速率，而不是在链路上的速率）</p>
<p>吞吐量：表示在单位时间内通过某个网络（或信道、接口）的数据量。单位b/s,kb/s,Mb/s</p>
<p>时延<img src="https://lyhlyhaa.github.io/post-images/1597221924901.png" alt="" loading="lazy"><br>
所谓高速链路只改变发送时延</p>
<p>时延带宽积：传播时延 x 带宽</p>
<p>RTT(往返时延)：从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，<br>
总共经历的时延。</p>
<p>面向连接三个阶段：建立连接   通信（数据传输） 释放连接</p>
<h1 id="物理层">物理层</h1>
<p>特性：<br>
1.机械特性 （比如器件尺寸）2.电气特性（电压范围） 3.功能特性（某种电平意义） 4.规程特性（又名过程特性）（不同功能的各种事件出现顺序）</p>
<p>通信交互方式：<br>
单工（单向通信，一条信道）、半双工（双向交替通信，两条信道）、全双工（双向同时通信，两条信道）</p>
<p>码元（ code）：<br>
在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。（码元离散状态有M种称为M进制码元）</p>
<figure data-type="image" tabindex="2"><img src="https://lyhlyhaa.github.io/post-images/1597324427854.png" alt="" loading="lazy"></figure>
<p>调制：<br>
1.基带调制（编码）：不归零制、归零制、曼切斯特编码、差分曼切斯特编码<br>
2.带通调制（转化为模拟信号）：调幅、调频、调相</p>
<p><img src="https://lyhlyhaa.github.io/post-images/1597461915732.png" alt="" loading="lazy"><br>
<strong>注意只有在奈式准则和香农定理中带宽才用Hz</strong></p>
<p>香农定理：<br>
<img src="https://lyhlyhaa.github.io/post-images/1597484235197.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1597479421625.png" alt="" loading="lazy"></p>
<p><img src="https://lyhlyhaa.github.io/post-images/1597480711254.png" alt="" loading="lazy"><br>
导向型：双绞线、同轴电缆、光纤</p>
<p>物理层设备：中继器、集线器（再生、放大信号，星型拓扑、不具备定向传输功能，不能分割冲突域）</p>
<p>信道复用：<br>
频分复用：用户再分配到一定的频带后，在通信过程中至始至终都占据这个频带；（并行）<br>
时分复用（TDM）：将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。（并发，类似于时间片）<br>
统计时分复用STDM：（谁来给谁分配时间片，不是无脑每个人都给）<br>
波分复用：就是光的频分复用<br>
码分复用：<br>
每个站被指派一个唯一的 m bit 码片序列。<br>
如发送比特 1，则发送自己的 m bit 码片序列，如发送比特 0，则发送该码片序列的二进制反码<br>
为表示方便，将0写为-1，1写为+1<br>
<strong>注意：两个不同站的码片序列正交</strong><br>
不同站的码片向量规格化内积为0**（规格化内积，对应位相乘之后相加，除以位数m）**<br>
任何一个码片向量和该码片向量自己的规格化内积都是1 。一个码片向量和该码片反码的向量的规格化内积值是 –1<br>
合并：各路数据在信道中线性相加；分离：合并的数据和源站规格化内积</p>
<h1 id="数据链路层">数据链路层</h1>
<p>结点:主机、路由器<br>
链路:网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。<br>
数据链路:网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。<br>
帧:链路层的协议数据单元，封装网络层数据报。</p>
<p>封装成帧、<br>
透明传输：字符填充法：转义字符ESC，开始SOH，结束EOT（<s>ETO，你被捕了，哈哈哈</s>）<br>
零比特填充法</p>
<p><strong>差错控制：有比特错和帧错两种，这里我们讨论比特错</strong><br>
检错编码：<br>
<img src="https://lyhlyhaa.github.io/post-images/1597982457147.png" alt="" loading="lazy"><br>
奇偶校验码：在传输的信息元前面加一位校验元（0 or 1），使1的个数为奇数或者偶数，检查收到的信息中1的个数是否与发送的相同（加了校验元后的）   特点：只能查出奇数个比特错误、检错能力为50%<br>
<img src="https://lyhlyhaa.github.io/post-images/1598061552412.png" alt="" loading="lazy"></p>
<p>纠错编码：海明码：<br>
<img src="https://lyhlyhaa.github.io/post-images/1598063025567.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1598063088754.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1598063184760.png" alt="" loading="lazy"><br>
检验纠错：<img src="https://lyhlyhaa.github.io/post-images/1598063292458.png" alt="" loading="lazy"></p>
<p><strong>流量控制：</strong>（在链路层窗口大小是确定的）<br>
链路层实现方法：接收方收不下就不回复确认<br>
停止等待协议：每发送一个帧之后发送，等待对方的确认，就停止收到确认之后再发送下一个<br>
信道利用率：发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率。<br>
<em>滑动窗口协议：</em><br>
后退N帧协议（GBN）：</p>
<p>两种链路：<br>
点对点链路：两个相邻节点通过一条链路相连，应用：PPP协议，常用于广域网<br>
广播式链路：常用于局域网，典型拓扑结构：总线型、星型（逻辑总线型）</p>
<p><strong>以太网：无连接、不可靠</strong><br>
MAC地址：48位二进制地址，前24位代表厂家<br>
CSMA/CD：争用期<img src="https://lyhlyhaa.github.io/post-images/1598089775570.png" alt="" loading="lazy"><br>
最小帧长：2τ *数据传输速率</p>
<p><strong>广域网</strong><br>
ppp协议（只支持全双工链路）<br>
<img src="https://lyhlyhaa.github.io/post-images/1598148331247.png" alt="" loading="lazy"><br>
除了字节填充，还可以采用零比特填充（当采用同步传输，即一连串的比特连续发送）<br>
出现五个连续1，则立即填入一个0</p>
<p>链路层设备：网桥&amp;交换机（分割冲突域，不能分割广播域）<br>
网桥根据MAC帧的目的地址对帧进行转发和过滤<br>
自学习：每个设备都发一次信息，就可以形成一个完整的转发表<br>
直接连接在交换机的设备独占带宽</p>
<h1 id="网络层">网络层</h1>
<p>传输单位为数据报</p>
<p><strong>数据交换</strong><br>
电路交换： 建立连接（呼叫/电路建立） -&gt; 通信 -&gt; 释放连接（拆除电路）<br>
传输时延最小<br>
数据量大，传送时间远大于呼叫时间则采用电路交换<br>
特点：独占资源（但是又有多路复用？什么东西！！！）</p>
<p>报文交换：<br>
类似分组交换，不过不分组<br>
分组交换：<br>
<img src="https://lyhlyhaa.github.io/post-images/1598153522928.png" alt="" loading="lazy"><br>
计算题中要注意的几点:<br>
1.单位换算:b/B,Mbps,kbps<br>
2是否考虑传播延迟<br>
3.时间至少是多少—选择最少跳数<br>
4.起始时间（从发送开始到接收完为止/从发送开始到发送完毕）<br>
5.是否有分组头部大小的开销<br>
6.报文交换时延更长，分组交换时延可能不是整数</p>
<p><img src="https://lyhlyhaa.github.io/post-images/1598155426118.png" alt="" loading="lazy"><br>
虚电路：建立连接（虚电路建立）-&gt; 数据传输  -&gt; 释放连接（虚电路释放）</p>
<p>**数据链路层：**MTU（最大传送单元）：以太网规定为1500字节</p>
<p>IP数据报格式：<img src="https://lyhlyhaa.github.io/post-images/1598185535426.png" alt="" loading="lazy"></p>
<pre><code>标识：同一数据报的分片使用同一标识。
标志只有2位有意义x _ _
中间位DF (Don't Fragment) :
DF=1，禁止分片
DF=0，允许分片
最低位MF (More Fragment) :
MF=1，后面“还有分片”
MF=0，代表最后一片/没分片
片偏移:指出较长分组分片后，某片在原分组中的相对位置。以8B为单位。
除了最后一个分片，每个分片长度一定是8B的整数倍。
</code></pre>
<p>IP地址：全世界唯一的32位/4字节标识符，标识路由器主机的接口<br>
&lt;网络号，主机号&gt;<br>
特殊IP地址：<br>
<img src="https://lyhlyhaa.github.io/post-images/1598175646432.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1598175981780.png" alt="" loading="lazy"></p>
<p>子网掩码：<br>
网络号全1，子网号全1，主机号全0<br>
与IP地址逐位相与（即只有1与1才返回1）就可以得到子网的网络地址</p>
<p>无分类编制CIDR<br>
1.消除了传统A类、B类和C类以及划分子网的概念<br>
2.把网络前缀都相同的IP地址组成一个CIDR地址块<img src="https://lyhlyhaa.github.io/post-images/1598186496327.png" alt="" loading="lazy"></p>
<p><code>最长前缀匹配：使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体</code></p>
<p>ARP协议（完成主机或路由器IP地址到MAC地址的映射，解决下一跳走那的）：<br>
先检查ARP高速缓存；<br>
<img src="https://lyhlyhaa.github.io/post-images/1598236165572.png" alt="" loading="lazy"><br>
同一网段内（网络号相同）：直接广播找MAC地址<br>
不是同一网段内：先找默认网关MAC地址，发到路由器</p>
<p>ICMP协议<br>
<code>注意：ICMP差错报告报文在**IP数据报的数据部分**</code><br>
不发送ICMP差错报文的情况<br>
<img src="https://lyhlyhaa.github.io/post-images/1598238808462.png" alt="" loading="lazy"><br>
<code>组播一点对多点，而不是广播向所有</code><br>
ICMP询问报文<br>
<img src="https://lyhlyhaa.github.io/post-images/1598238725933.png" alt="" loading="lazy"></p>
<pre><code>DHCP协议
动态主机配置协议DHCP是应用层协议，使用客户/服务器方式，客户端和服务端通过广播方式进行交互，基于UDP。
DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与P地址，
允许地址重用，支持移动用户加入网络，支持在用地址续租。
1.主机广播DHCP发现报文(DHCPDISCOVER)
2.DHCP服务器广播DHCP提供报文(DHCPOFFER)
3.主机广播DHCP请求报文(DHCPREQUEST)
4.DHCP服务器广播DHCP确认报文(DHCPACK)
</code></pre>
<p>路由算法<br>
<img src="https://lyhlyhaa.github.io/post-images/1598240383909.png" alt="" loading="lazy"></p>
<p>RIP<br>
距离向量算法<br>
<img src="https://lyhlyhaa.github.io/post-images/1598242047926.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>