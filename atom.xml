<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lyhlyhaa.github.io</id>
    <title>混子协会会长</title>
    <updated>2020-07-28T13:25:13.710Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lyhlyhaa.github.io"/>
    <link rel="self" href="https://lyhlyhaa.github.io/atom.xml"/>
    <logo>https://lyhlyhaa.github.io/images/avatar.png</logo>
    <icon>https://lyhlyhaa.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 混子协会会长</rights>
    <entry>
        <title type="html"><![CDATA[计网-物理层]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-wang-wu-li-ceng/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-wang-wu-li-ceng/">
        </link>
        <updated>2020-07-28T11:44:36.000Z</updated>
        <content type="html"><![CDATA[<p>1.假定某信道受奈氏准则限制的最高码元速率为20000码元/秒。如果采用振幅调制，把码元的振幅划分为16个不同等级来传送，那么可以获得多高的数据率（bit/s）？<br>
解：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>R</mi><mo>∗</mo><mi>L</mi><mi>o</mi><mi>g</mi><mn>2</mn><mi mathvariant="normal">（</mi><mn>16</mn><mi mathvariant="normal">）</mi><mo>=</mo><mn>20000</mn><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>∗</mo><mn>4</mn><mo>=</mo><mn>80000</mn><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">C=R*Log2（16）=20000b/s*4=80000b/s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mord">6</span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span></span></p>
<p>最基本的二元制调制方法有以下几种：<br>
调幅(AM)：载波的振幅随基带数字信号而变化。<br>
调频(FM)：载波的频率随基带数字信号而变化。<br>
调相(PM) ：载波的初始相位随基带数字信号而变化。<br>
调制方法就是改变码元携带的比特的信息，码元传输速率一般固定，调制之后，传输比特的速率就上升了</p>
<hr>
<p>2.用香农公式计算一下，假定信道带宽为3100Hz，最大信息传输速率为35kbit/s，那么若想使最大信息传输速率增加60％，问信噪比S/N应增大到多少倍？如果在刚才计算出的基础上将信噪比S/N再增大到10倍，问最大信息速率能否再增加20％？<br>
解：<br>
C=Wlog2(1+S/N)b/s-àSN1=2*（C1/W）-1=2*（35000/3100）-1<br>
SN2=2*（C2/W）-1=2*（1.6<em>C1/w）-1=2</em>（1.6<em>35000/3100）-1<br>
SN2/SN1=100信噪比应增大到约100倍。C3=Wlong2（1+SN3）=Wlog2（1+10</em>SN2）C3/C2=18.5%如果在此基础上将信噪比S/N再增大到10倍，最大信息通率只能再增加18.5%左右</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">香</mi><mi mathvariant="normal">农</mi><mi mathvariant="normal">公</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">：</mi><mi>C</mi><mo>=</mo><mi>W</mi><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>(</mo><mn>1</mn><mo>+</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo>)</mo><mo>(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">香农公式：C = W log2(1+S/N) (bit/s)   
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">香</span><span class="mord cjk_fallback">农</span><span class="mord cjk_fallback">公</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></span></p>
<p>W 为信道的带宽（以 Hz 为单位）<br>
信噪比（dB）：10 log10(S/N) (dB)<br>
S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率</p>
<hr>
<p>3.　假定有一种双绞线的衰减是0.7dB/km（在1kHz时），若容许有20dB的衰减，试问使用这种双绞线的链路的工作距离有多长？如果要使这种双绞线的工作距离增大到100公里，问应当使衰减降低到多少？<br>
解：使用这种双绞线的链路的工作距离为=20/0.7=28.6km   衰减应降低到20/100=0.2db</p>
<hr>
<p>4.共有四个站进行码分多址CDMA通信。四个站的码片序列为：<br>
A：（–1–1–1＋1＋1–1＋1＋1）<br>
B：（–1–1＋1–1＋1＋1＋1–1）<br>
C：（–1＋1–1＋1＋1＋1–1–1）<br>
D：（–1＋1–1–1–1–1＋1–1）<br>
现收到这样的码片序列:（–1＋1–3＋1–1–3＋1＋1）。问哪个站发送数据了？发送数据的站发送的是1还是0？<br>
解：<br>
S•A=（＋1－1＋3＋1－1＋3＋1＋1）／8=1，A发送1<br>
S•B=（＋1－1－3－1－1－3＋1－1）／8=－1，B发送0<br>
S•C=（＋1＋1＋3＋1－1－3－1－1）／8=0，C无发送<br>
S•D=（＋1＋1＋3－1＋1＋3＋1－1）／8=1，D发送1</p>
<p>码片序列：<br>
每个站被指派一个唯一的 m bit 码片序列。<br>
如发送比特 1，则发送自己的 m bit 码片序列。<br>
如发送比特 0，则发送该码片序列的二进制反码<br>
为表示方便，将0写为-1，1写为+1</p>
<p><strong>注意：两个不同站的码片序列正交</strong><br>
不同站的码片向量规格化内积为0<br>
任何一个码片向量和该码片向量自己的规格化内积都是1 。<br>
一个码片向量和该码片反码的向量的规格化内积值是 –1。</p>
<hr>
<p>5.　试比较ADSL、HFC以及FTTx接入技术的优缺点。解：<br>
ADSL技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。成本低，易实现，但带宽和质量差异性大。HFC网的最大的优点具有很宽的频带，并且能够利用已经有相当大的覆盖面的有线电视网。要将现有的450MHz单向传输的有线电视网络改造为750MHz双向传输的HFC网需要相当的资金和时间。FTTx（光纤到……）这里字母x可代表不同意思。可提供最好的带宽和质量、但现阶段线路和工程成本太大。</p>
<p>补充问答题1、怎样更改自己电脑的MAC地址（用文字描述操作步骤）解：</p>
<p>打开设备管理器<br>
右键点击适配器。从菜单中点击属性来打开网络适配器的属性窗口。<br>
点击高级选项卡。找到“网络地址”或“本地管理地址”条目。点击该条目，将在右侧看到“值”（Value）的字样和输入框。点击单选按钮来启用“值”（Value）的输入框。<br>
输入新的MAC地址。MAC地址的格式是，不包含破折号和冒号的12位数值。<br>
重启计算机来启用变更。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小生成树]]></title>
        <id>https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/">
        </link>
        <updated>2020-07-26T07:00:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="克鲁斯卡尔算法">克鲁斯卡尔算法：</h1>
<p>1.把边进行排序，按从从小到大的顺序。<br>
2.贪心算法，找未加入通路的权值最小的边<br>
3.判断是否形成环，如果形成，则跳过这一条边，返回第二步，如果没有，则把找到的边加入通路中，返回第二步<br>
4.当通路中的的边的个数等于点的个数-1，则最小生成树已经形成。</p>
<p><em>排序可以用sort函数，边的存储可以用结构体数组</em><br>
<strong>主要是判断是否形成环：</strong><br>
使用<a href="https://blog.csdn.net/qq_41593380/article/details/81146850">并查集</a><br>
<strong>初始化</strong></p>
<pre><code>void init(int n)
{
    for (int i = 1; i &lt;= n; ++i)
        fa[i] = i;
}
</code></pre>
<p><strong>路径压缩查找</strong></p>
<pre><code>int find(int x)
{
    return x == fa[x] ? x : (fa[x] = find(fa[x]));//
}
</code></pre>
<p><strong>合并</strong></p>
<pre><code>ivoid merge(int i, int j)
{
    fa[find(i)] = find(j);
}//合并
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐波拉契数列]]></title>
        <id>https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/</id>
        <link href="https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/">
        </link>
        <updated>2020-07-24T07:30:17.000Z</updated>
        <content type="html"><![CDATA[<p>。。。。<br>
今晚整理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[骨牌问题（铺地砖）]]></title>
        <id>https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/</id>
        <link href="https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/">
        </link>
        <updated>2020-07-24T07:14:41.000Z</updated>
        <content type="html"><![CDATA[<p>暂时看一下别的博客（https://blog.csdn.net/xiangAccepted/article/details/80229187?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三色旗问题]]></title>
        <id>https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/</id>
        <link href="https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/">
        </link>
        <updated>2020-07-24T02:54:57.000Z</updated>
        <content type="html"><![CDATA[<p>要用到三个指针：一个前指针begin，一个中指针current，一个后指针end，current指针遍历整个数组序列，当</p>
<p>current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ；<br>
current指针所指元素为1时，不做任何交换（即球不动），而后current++ ；<br>
current指针所指元素为2时，与end指针所指的元素交换，而后，current指针不动，end-- 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络（考试）]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-suan-ji-wang-luo/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-suan-ji-wang-luo/">
        </link>
        <updated>2020-07-23T08:31:33.000Z</updated>
        <content type="html"><![CDATA[<p><em>图文无关😂</em></p>
<hr>
<h2 id="一-选择题">一、选择题</h2>
<p>(1)	Socket是由（ 　D    ）组成的。<br>
A.主机名   <strong>B. MAC地址及端口号</strong><br>
C.IP地址以及MAC地址       D. IP地址及端口号<br>
(2)	　在OSI参考模型中，实现系统间二进制信息块的正确传输，为上一层提供可靠、无错误数据信息的协议层是(   A    ) 。<br>
<strong>A. 数据链路层</strong>     B. 物理层        C. 网络层    D. 传输层<br>
(3) 在TCP/IP网络中，提供主机A和主机B应用层之间通信的层是（   B ）。<br>
A、应用层         <strong>B.传输层</strong>        C、IP层       D、网络接口层；<br>
<strong>在TCP/IP四层模型中，提供两主机应用层之间通信的层是传输层，传输层通过端口值来实现两台主机应用程序的通信。IP层则是负责提供机器之间的通信，IP层通过IP地址来标识不同的主机，实现机器之间的通信</strong><br>
(4) 路由器主要实现了（  C  ）的功能。<br>
A. 数据链路层、网络层与应用层  　  　 B. 物理层、数据链路层与网络层<br>
　     <strong>C. 网络层与传输层</strong>　　　　　　　　    　D. 物理层与传输层<br>
(5) 当客户端请求域名解析时，如果本地DNS服务器不能完成解析，就把请求发送其他服务器，依次进行查询，直到把域名解析结果返回请求的客户端，这种方式（  B  ）<br>
A. 迭代解析               　　 <strong>B. 迭代解析与递归解析相结合</strong><br>
C. 递归解析　　　　　　　　　　D.高速缓存解析<br>
(6)关于TCP和UDP下列说法中正确的是（A    ）。<br>
<strong>A．TCP和UDP端口分别拥有自己的端口号，二者互不干扰，可以共存于同一台主机；</strong>　　<br>
B．TCP和UDP端口分别拥有自己的端口号，但二者不能共存于同一台主机；<br>
C．TCP和UDP端口没有本质区别，二者互不干扰，可以共存于同一台主机；<br>
D．TCP和UDP端口没有本质区别，但二者相互干扰，不能共存于同一台主机；<br>
(7) 一条线路每1/16秒采样一次，传输信号共有16种状态，器传输速率是（  C ）。<br>
A. 16bps          B. 48bps     ** C. 64bps**          D. 256bps<br>
<strong>16种状态可以用4bit二进制数表示，每秒采样16次，所以每秒需要传的数据量就是64bit。如果不考虑信道编码需要增加的冗余比特，传输速率就是64bit/s。</strong><br>
(8) 关于客户/服务器应用模式，以下（  A ）说法是正确的。<br>
<strong>A. 由服务器和客户机协同完成一件任务；</strong>　　B. 在服务器端，每次只能为一个客户服务；<br>
C. 将应用程序下载到本地执行；　　　　　　D.许多终端共享主机资源的多用户系统；<br>
(9)一个16端口的二层以太交换机，冲突域和广播域的个数分别是(      )。<br>
　　　A. １，１        B . １６，１６      C. １，１６        <strong>D . １６，１</strong><br>
<img src="https://lyhlyhaa.github.io/post-images/1595924992303.png" alt="" loading="lazy"></p>
<h2 id="二-填空题每题2分共20分">二、	填空题（每题2分，共20分）</h2>
<p>1、假设某信道能传输最高码元速率为1200码元/秒，使用幅度-相位调制技术，由幅度和相位组成32种码元，那么它在信道上可以达到数据传输速率是_________波特 。<br>
2、128二进制位的IPv6地址2819:00AF:00000:0000:0035:0CB2：B217，我们使用IPv6的压缩表示方式可将它记_____________ 。<br>
3、在路由信息协议RIP中，更新路由表依据是：若相邻X路由器说“我到目的网络Y距离为N，则收到此信息K路由器知道“若将下一站路由器为X，则我的网络Y的距离为________ ”。<br>
4、在TCP中首部的可选项中最多可指明已收到的信息块___________个字节块。<br>
5、设有下面４个网络：170.58.129.0/24、176.58.130.0/24、176.58.132.0/24和176.58.133.0/24，如果进行路由汇聚，能覆盖4条路由地址是______________________。<br>
6、若在发送端HDLC帧的数据部分出现比特串是“010111110101”，为了解决透明问题，采用比特填充后，     则接收端收到的是____________ 。<br>
7、A向B发送消息Y，并使用公钥体制进行数字签名。 设私有密秘钥SKA和公开秘钥PKA, E表示加密算法，    D表示解密算法，则B要保留的证据是____________。<br>
8、SNMP规定了5种PDU，当代理者进程向 管理者 进程报告发生的事件是采用___________报文。<br>
9、现有  IP Address   193.18.14.8,查表知道 IP地址在TLV编码中T字段值是40，那么该地址的TLV编码是___________。<br>
10、在TCP协议中，采用___________来区分不同的应用进程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路径算法]]></title>
        <id>https://lyhlyhaa.github.io/post/zui-duan-lu-jing-suan-fa/</id>
        <link href="https://lyhlyhaa.github.io/post/zui-duan-lu-jing-suan-fa/">
        </link>
        <updated>2020-07-22T12:05:34.000Z</updated>
        <content type="html"><![CDATA[<p>说起来这个算法做过很多次了，学图论的时候写过实验报告，可是现在做题又给忘了，惭愧。</p>
<hr>
<h1 id="dijkstra算法">Dijkstra算法</h1>
<p>1.<strong>初始化</strong>:先找出从源点vo到各终点v的直达路径(Vo,Vk) ,<br>
即通过一条弧到达的路径。<br>
2.<strong>选择</strong>:从这些路径中找出一条长度最短的路径(Vo,u) 。<br>
3.<strong>更新</strong>:然后对其余各条路径进行适当调整:<br>
若在图中存在弧(u,Vk) ，且(V,U) + (u,Vk) &lt; (Vo,Vk),<br>
则以路径(Vo,U,Vk) 代替(Vo,Vk) 。<br>
在调整后的各条路径中，再找长度最短的路径，依此类推。<br>
设计一个s[]数组，来存已经在最短路径中的点</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dp]]></title>
        <id>https://lyhlyhaa.github.io/post/dp/</id>
        <link href="https://lyhlyhaa.github.io/post/dp/">
        </link>
        <updated>2020-07-22T01:53:51.000Z</updated>
        <content type="html"><![CDATA[<p>先是不说人话的概念：dp（动态规划）是求解决策过程最优化的数学方法。利用各个阶段之间的关系，逐个求解，最终求得全局最优解，需要确认原问题与子问题、动态规划状态、边界状态、边界状态结值、状态转移方程<br>
看不懂啊！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈]]></title>
        <id>https://lyhlyhaa.github.io/post/zhan/</id>
        <link href="https://lyhlyhaa.github.io/post/zhan/">
        </link>
        <updated>2020-07-21T01:59:07.000Z</updated>
        <content type="html"><![CDATA[<p>栈（stack）说明及举例：</p>
<p>使用栈，要先包含头文件 ： <code>#include&lt;stack&gt;</code></p>
<p>定义栈，以如下形式实现： <code>stack&lt;Type&gt; s;</code> 其中Type为数据类型（如 int，float,char等）。</p>
<p>栈的主要操作：</p>
<pre><code>s.push(item);		//将item压入栈顶
s.pop();			//删除栈顶的元素，但不会返回
s.top();			//返回栈顶的元素，但不会删除
s.size();			//返回栈中元素的个数
s.empty();			//检查栈是否为空，如果为空返回true，否则返回false 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[指针疑问]]></title>
        <id>https://lyhlyhaa.github.io/post/zhi-zhen-yi-wen/</id>
        <link href="https://lyhlyhaa.github.io/post/zhi-zhen-yi-wen/">
        </link>
        <updated>2020-07-20T09:05:40.000Z</updated>
        <content type="html"><![CDATA[<p>指针<br>
*号：指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。* 运算符，也称为间接访问运算符，返回指针指向存储单元的数值；也称为指向运算符号：<br>
注意：<br>
指针运算符是取地址运算符号的反运算符号<br>
*(&amp;a) = 10;<br>
&amp;号：每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址，&amp;运算符，返回操作数的内存地址</p>
<pre><code class="language-cpp">int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
   ip = &amp;var;  /* 在指针变量中存储 var 的地址 */
   printf(&quot;Address of var variable: %p\n&quot;, &amp;var  );//Address of var variable: bffd8b3c
   /* 在指针变量中存储的地址 */
   printf(&quot;Address stored in ip variable: %p\n&quot;, ip );//Address stored in ip variable: bffd8b3c
   /* 使用指针访问值 */
   printf(&quot;Value of *ip variable: %d\n&quot;, *ip );//Value of *ip variable: 20
</code></pre>
<p><strong>突然想起来定义的时候，int *p就是int* p,其实是相当于一个int*类型的变量p，p就是一个地址值，简而言之，p是一个地址值，而*p就是p所指向的东西，可以是一个整型变量，也可以指向一个链表节点，也可以是一个二叉树节点。</strong></p>
<pre><code class="language-cpp"> int a=1;
 int *pa;
 pa=&amp;a; //&amp;a 是一个指针表达式。
 printf(&quot;*a=%p\n&quot;,&amp;a);
 printf(&quot;*pa=%d\n&quot;,*pa);//*pa是一个值，就是pa所指向的a的值 
 printf(&quot;pa=%p\n&quot;,pa);//pa是一个地址，pa指向a，所以pa地址与a相同 
 printf(&quot;&amp;*pa=%p\n&quot;,&amp;(*pa));//pa指向a，*pa就是a,&amp;(*pa)即*pa的地址就是a的地址 
 /*
 *a=000000000062FE14
 *pa=1
 pa=000000000062FE14
 &amp;*pa=000000000062FE14
 */
 printf(&quot;\n&quot;); 
 int** ptr;
 ptr=&amp;pa;//由此可知*ptr=pa、**ptr=*pa 
 printf(&quot;&amp;pa=%p\n&quot;,&amp;pa);//pa指针本身的地址 
 printf(&quot;ptr=%p\n&quot;,ptr);//ptr指向的是pa本身地址 
 printf(&quot;*ptr=%p\n&quot;,*ptr);//*ptr指向的是pa指针所指向的地址，就是a的地址
 printf(&quot;**p=%d\n&quot;,**ptr);// 
 /*
 &amp;pa=000000000062FE08
 *ptr=000000000062FE14
 ptr=000000000062FE08
 **p=1
 */
</code></pre>
]]></content>
    </entry>
</feed>