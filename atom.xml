<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lyhlyhaa.github.io</id>
    <title>混子协会会长</title>
    <updated>2020-07-17T03:49:58.576Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lyhlyhaa.github.io"/>
    <link rel="self" href="https://lyhlyhaa.github.io/atom.xml"/>
    <logo>https://lyhlyhaa.github.io/images/avatar.png</logo>
    <icon>https://lyhlyhaa.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 混子协会会长</rights>
    <entry>
        <title type="html"><![CDATA[优先队列&&贪心算法]]></title>
        <id>https://lyhlyhaa.github.io/post/you-xian-dui-lie/</id>
        <link href="https://lyhlyhaa.github.io/post/you-xian-dui-lie/">
        </link>
        <updated>2020-07-14T02:46:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="优先队列">优先队列</h1>
<p>首先要包含头文件</p>
<pre><code>#include&lt;queue&gt;
</code></pre>
<p>定义：</p>
<pre><code>priority_queue&lt;Type, Container, Functional&gt;
</code></pre>
<p>//升序队列</p>
<pre><code>priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;
</code></pre>
<p>//降序队列</p>
<pre><code>priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;
</code></pre>
<p>和队列基本操作相同:<br>
top 访问队头元素<br>
empty 队列是否为空<br>
size 返回队列内元素个数<br>
push 插入元素到队尾 (并排序)<br>
emplace 原地构造一个元素并插入队列<br>
pop 弹出队头元素<br>
swap 交换内容</p>
<h1 id="贪心算法">贪心算法</h1>
<p><img src="https://lyhlyhaa.github.io/post-images/1594901952410.png" alt="" loading="lazy"><br>
<a href="https://blog.nowcoder.net/n/c3df2ee180fe4657b64ce09c571c99bc">原博客</a><br>
发现一个说的很好的博客<a href="https://blog.csdn.net/weixin_44820625/article/details/104088362">贪心算法总结</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[程设]]></title>
        <id>https://lyhlyhaa.github.io/post/cheng-she/</id>
        <link href="https://lyhlyhaa.github.io/post/cheng-she/">
        </link>
        <updated>2020-07-11T03:05:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1127数列">1127数列</h1>
<p>1.刚开始没有找规律，先是一个一个往后找，超时。然后另一种方法开了一个数组，全部存到数组里，内存超限了。之后找到规律，在一段时间的无序后，会开始循环，循环的内容可以自己定（从1，2开始或者从4，8开始等等）<br>
2.找到规律后考虑两种特殊情况，<em>a或者b中有0，a=b=1</em>，单独处理，其他的按题循环，找到循环开始的数（例如1，2），则跳出循环。对循环数组长度取余来获得所求的值。在循环中还要考虑出现5，乘起来出现整10的情况。</p>
<hr>
<h1 id="1263-矩形面积的并">1263 矩形面积的并</h1>
<p>1.相交矩形的四边</p>
<pre><code>xc1 = max(min(x1,x2),min(x3,x4));
xc2 = min(max(x1,x2),max(x3,x4));
yc1 = max(min(y1,y2),min(y3,y4));
yc2 = min(max(y1,y2),max(y3,y4));
</code></pre>
<p>2.判断矩形是否相交</p>
<pre><code>xc1 &lt;= xc2&amp;&amp;yc1 &lt;= yc2
</code></pre>
<hr>
<h1 id="1252-matrix-word">1252 Matrix Word</h1>
<p>1.判断矩阵中该行以及该列是否有一样的字符</p>
<pre><code>int j(int i, int j,char c){
	for(int k = 0; k &lt; m; k++)
if(mat[i][k] == c &amp;&amp; k != j) return 0;
	for(int k = 0; k &lt; n; k++)
if(mat[k][j] == c &amp;&amp; k != i) return 0;
	return 1;
}
</code></pre>
<p>2.遍历矩阵，如果遍历到的啊a[i][j]是行，列中唯一的，则输出</p>
<hr>
<h1 id="1251哥伦比亚数">1251哥伦比亚数</h1>
<p>1.如果n是自我数，则必定有一个小于n的数m+m的数码之和等于n，由题目可知m的数码之和不会超过81，由此可得：从后往前开始找a，因为数码和最大81，所以a&gt;(原数字n)-81</p>
<hr>
<h1 id="1253robot">1253Robot</h1>
<p>有N个任务需要Robot去完成，这个N个任务的地点在一个数轴上，坐标为1到n。<br>
每个任务需要先完成ai个任务才能开始去做。<br>
Robot可以在直线上左右移动，初始位置位于任务1的地点，<br>
方向朝向数轴正方向。请问Robot最少转换多少次方向可以完成所有的任务。</p>
<p>1.已经完成的任务数  &gt;= ai<br>
2.先从左到右遍历，设置一个标记数组，符合条件置1<br>
3.如果没有全部完成，则从右到左遍历</p>
<hr>
<h1 id="1262fish">1262Fish</h1>
<p>1.开始用数组做，超时了。<br>
2.使用<a href="https://lyhlyhaa.github.io/post/you-xian-dui-lie/">优先队列</a>和贪心算法（其实并不是很明白贪心），定义一个结构体</p>
<pre><code>struct node
{
    int a,b;
    friend bool operator &lt;(node A,node B)//价值高的优先级高
    {
        return A.a&lt;B.a;
    }
};
</code></pre>
<p>a是第一次捕鱼数，b是每次减少的捕鱼数，利用优先队列将输入的值按a排序，每次改变a的值，相当于每次都是第一次捕鱼</p>
<pre><code>ans+=now.a;
now.a = max(0,now.a-now.b);
m--;
</code></pre>
<hr>
<h1 id="1281-cute-string">1281  Cute String</h1>
<p>1.条件：单词（每个单词之间用一个空格隔开）数量超过10，或者句子中字母种类（不区分大小写）超过10个则不成立<br>
2.非常简单，就不写了😀</p>
<hr>
<h1 id="1294-enquiry">1294  Enquiry</h1>
<p>1.直接打表解决🙏<br>
2.有个小问题，区分字符串和字符数组<br>
<img src="https://lyhlyhaa.github.io/post-images/1594888443566.png" alt="" loading="lazy"></p>
<hr>
<h1 id="1280-string-hash">1280  String Hash</h1>
<p>1.思路比较简单，就26进制转换10进制，取余就行。但是不可以完全转换之后再去取余，数字太大，<br>
所以要在每一位转换的时候都取余一次，加起来就是答案</p>
<hr>
<h1 id="1272-robot">1272  Robot</h1>
<p>1.成立条件，四个方向必有一方是为0的，然后暴力就ok</p>
]]></content>
    </entry>
</feed>