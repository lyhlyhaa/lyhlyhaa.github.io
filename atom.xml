<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lyhlyhaa.github.io</id>
    <title>混子协会会长</title>
    <updated>2020-10-04T12:09:38.309Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lyhlyhaa.github.io"/>
    <link rel="self" href="https://lyhlyhaa.github.io/atom.xml"/>
    <logo>https://lyhlyhaa.github.io/images/avatar.png</logo>
    <icon>https://lyhlyhaa.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 混子协会会长</rights>
    <entry>
        <title type="html"><![CDATA[一个微信小程序]]></title>
        <id>https://lyhlyhaa.github.io/post/yi-ge-wei-xin-xiao-cheng-xu/</id>
        <link href="https://lyhlyhaa.github.io/post/yi-ge-wei-xin-xiao-cheng-xu/">
        </link>
        <updated>2020-10-02T02:10:24.000Z</updated>
        <content type="html"><![CDATA[<p>某些基础知识：<br>
<img src="https://lyhlyhaa.github.io/post-images/1601604660940.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1601604730267.png" alt="" loading="lazy"></p>
<pre><code>wxml文件类似于我们熟悉的HTML文件，用来编写页面的标签和骨架，不同的是wxml文件里的标签元素不可以使用HTML标签，只能使用小程序自己封装的一些组件，这些组件也是我们后面要重点学习的知识。
</code></pre>
<pre><code>wxss文件的作用类似于我们熟悉的CSS文件，用于编写小程序的样式，实际上小程序的样式编写语言就是CSS，只是把.css文件换成了.wxss文件
</code></pre>
<pre><code>json文件用来配置页面的样式与行为。
js文件类似于我们前端编程中的JavaScript文件，用来编写小程序的页面逻辑。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[逆序数]]></title>
        <id>https://lyhlyhaa.github.io/post/ni-xu-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/ni-xu-shu/">
        </link>
        <updated>2020-08-01T09:15:57.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/dlengong/article/details/7594919?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.channel_param">文章</a><br>
1.两层循环<br>
一猜就会超时，后来试了一下，果然。<br>
2.归并排序<br>
把数组分成两份，分别进行排序，然后合并<br>
会用到递归，从最开始的数组，到整个区间只有一个元素结束，即l==r<br>
<img src="https://lyhlyhaa.github.io/post-images/1596333420953.gif" alt="" loading="lazy"><br>
合并操作：<br>
<img src="https://lyhlyhaa.github.io/post-images/1596333135649.gif" alt="" loading="lazy"><br>
在两个分出来的数组比较完之后，把未填入的数组剩下的数依次（因为数组已经排好序）填入</p>
<pre><code>while(i&lt;=mid) temp[k++] = a[i++];  
while(j&lt;=right) temp[k++] = a[j++];
</code></pre>
<p>用归并求逆序数的关键就在于<br>
Seq1：3  4  5<br>
Seq2：2  6  8  9<br>
合并成一个有序序:</p>
<p>Seq：2  3  4  5  6  8  9</p>
<p>对于序列seq1中的某个数a[i],序列seq2中的某个数a[j]，如果a[i]&lt;a[j],没有逆序数，如果a[i]&gt;a[j]，那么逆序数为seq1中a[i]后边元素的个数(包括a[i])，即len1-i+1,<br>
3.<a href="http://www.cppblog.com/Ylemzy/articles/98322.html">树状数组</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统]]></title>
        <id>https://lyhlyhaa.github.io/post/cao-zuo-xi-tong/</id>
        <link href="https://lyhlyhaa.github.io/post/cao-zuo-xi-tong/">
        </link>
        <updated>2020-08-01T02:21:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第1章-操作系统概述">第1章 操作系统概述</h1>
<h2 id="11-什么是操作系统">1.1 什么是操作系统</h2>
<p><em>操作系统的定义（掌握）</em><br>
操作系统是计算机系统中最基础，最重要的<strong>系统软件</strong>，是其他软件的支撑软件。<br>
<em>计算机系统的组成（理解）</em><br>
采用冯诺依曼体系结构，由运算器、控制器、存储器、输入输出（I/O）设备五大部件组成。<br>
<em>操作系统与计算机系统（理解）</em><br>
计算机系统由软件、硬件和数据三部分组成，操作系统是配置在计算机硬件上的第一层软件。</p>
<h2 id="12-操作系统的发展过程理解">1.2 操作系统的发展过程（理解）</h2>
<p>简单计算机系统（无操作系统）：用户独占操作系统、<br>
单道批处理系统：自动性、顺序性和单道性（内存中只允许一道程序）、<br>
多道批处理系统：交替执行<img src="https://lyhlyhaa.github.io/post-images/1596942394126.png" alt="" loading="lazy"><br>
<code>允许多个用户将若干作业提交给计算机脱机处理的操作系统是多道批处理系统</code><br>
宏观并行，微观串行，多道性<br>
分时系统：交互性、及时性、独立性、多路性<br>
<strong>批处理系统、分时系统的出现标志着操作系统的形成</strong><br>
实时系统：及时性、交互性、独立性、多路性和高可靠性</p>
<p><strong>并行是指两个或者多个事件在同一时刻发生;而并发是指两个或多个事件在同一时间间隔内发生。</strong></p>
<h2 id="13-操作系统的主要功能掌握">1.3 操作系统的主要功能（掌握）</h2>
<p>处理机管理：进程控制、进程同步、进程通信和进程调度<br>
存储器管理：内存分配、内存保护、地址映射、内存扩充<br>
设备管理：缓冲区管理、设备分配、设备处理、虚拟设备管理<br>
文件管理：<br>
及用户接口：命令接口、程序接口、图形接口<br>
<code>基本特征:并发性、共享性、虚拟性 、异步性</code></p>
<h1 id="第2章-中断">第2章 中断</h1>
<h2 id="21-中断的基本概念理解">2.1 中断的基本概念（理解）</h2>
<p>目态（用户态，权限低） 管态（核心态）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597117788357.png" alt="" loading="lazy"><br>
中断的作用、中断类型、中断嵌套、中断优先级和中断屏蔽<br>
中断寄存器（每个中断源都有，中断发生时的相关信息记录在该存储器中）、<br>
程序状态字（PSW）：</p>
<h2 id="22-中断在操作系统中的地位了解">2.2 中断在操作系统中的地位（了解）</h2>
<p>中断是多道程序并发执行的推动力<br>
操作系统是由中断驱动的</p>
<h2 id="23-中断响应过程理解">2.3 中断响应过程（理解）</h2>
<h2 id="24-中断处理过程掌握">2.4 中断处理过程（掌握）</h2>
<p>中断处理流程、中断服务程序</p>
<h2 id="25-向量中断了解">2.5 向量中断（了解）</h2>
<h1 id="第3章-进程描述和控制">第3章 进程描述和控制</h1>
<h2 id="31-进程概述">3.1 进程概述</h2>
<p>程序的顺序执行及其特征（理解）<br>
程序的并发执行及其特征（理解）<br>
进程的概念及其特征（掌握）<br>
程序是完成特定任务的一组指令的结合，可以永久保存，具有静态性；<br>
进程是程序在某一数据结构上的一次执行过程，是系统进行资源分配和调度的基本单位，具有动态性；<br>
一个进程可以包含多个程序，一个程序也可以被多个进程执行。</p>
<p><strong>动态性</strong><br>
进程状态（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597134258032.png" alt="" loading="lazy"><br>
进程控制块（理解）PCB<br>
PCB是进程的唯一标识符</p>
<h2 id="32-进程控制理解">3.2 进程控制（理解）</h2>
<p>进程创建和终止<br>
进程阻塞和唤醒<br>
进程挂起和激活<br>
<img src="https://lyhlyhaa.github.io/post-images/1597136342534.png" alt="" loading="lazy"></p>
<p>服务器进程为多个客户进程提供服务或资源时，采用不阻塞发送，阻塞接收的消息传递方式较为常见。</p>
<h2 id="33-线程">3.3 线程</h2>
<p><em>线程简介（理解）</em><br>
线程是基本的cpu执行单元，调度和分派的基本单位，程序执行流的最小单位<br>
进程是资源分配的基本单位<br>
一个进程的线程共享该进程的全局变量、打开的文件、I/O资源<br>
<em>多线程（掌握）</em><br>
线程实现与线程模型（理解）<br>
多对一；一对一；多对多<br>
<img src="https://lyhlyhaa.github.io/post-images/1597286385098.png" alt="" loading="lazy"><br>
<strong>注意：一对一优缺点反了</strong></p>
<h2 id="34-互斥和同步">3.4 互斥和同步</h2>
<p>并发原理：临界资源、临界区等多种术语（掌握）<br>
互斥：多个进程因争用临界区内的共享资源而互斥的执行，即当一个进程在临界区访问共享资源时，其它进程不能进入该临界区访问任何共享资源。<br>
同步：系统中有一些相互合作、协同工作的进程，它们之间的相互联系称为进程的同步。<br>
临界区：是一段程序代码，进程将在此代码中访问共享的资源，当另一个进程已经在该代码中运行时，则该进程不能在这段代码中执行。<br>
临界资源：多个进程间采取互斥的方式实现对临界资源的共享访问。<br>
死锁：两个或两个以上的进程因其中的每个进程都在等待其它进程执行完毕而不能继续执行，这样的情形称为死锁。<br>
饥饿：是指一个可运行的进程虽然能继续执行，但被调度程序无限期的忽视而不能执行的情况 。</p>
<p>硬件同步（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597289851472.png" alt="" loading="lazy"><br>
信号量机制（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597307073833.png" alt="" loading="lazy"><br>
管程机制（理解）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597457450240.png" alt="" loading="lazy"><br>
三个经典的进程同步问题（掌握）<br>
生产者-消费者（get） 注意：当缓冲区已满，即empty为0，full为n，若mutex的p操作在前，则会死锁<br>
读者-写者（我裂开了）当一个进程允许并发，和别的互斥，设置整型信号量记录同时运行的进程，并且要设置一个记录型信号量来让这个整型信号量互斥访问<br>
哲学家就餐问题 主要解决死锁问题，（信息量数组）</p>
<p>消息传递（理解）</p>
<h1 id="第4章-调度与死锁">第4章 调度与死锁</h1>
<h2 id="41调度简介理解">4.1调度简介（理解）</h2>
<h2 id="调度的基本概念-调度原则调度原则42-调度算法掌握">调度的基本概念、调度原则<br>
<img src="https://lyhlyhaa.github.io/post-images/1597285417811.png" alt="" loading="lazy"><br>
调度原则：<img src="https://lyhlyhaa.github.io/post-images/1597544207270.png" alt="" loading="lazy"><br>
4.2 调度算法（掌握）</h2>
<p>先来先服务：按进入队列的先后顺序（以等待时间来）<br>
短作业优先：当前已到达的运行时间最短的优先（以服务时间）<br>
最高响应比优先：<br>
<code>响应比：（等待时间+服务时间）/服务时间</code><br>
以上多用于早期的批处理系统中<br>
优先级：每个作业（进程）有各自的优先级，调度时选择优先级最高的进程<br>
<code>有抢占式和非抢占式，会发生饥饿、实时系统</code><br>
时间片轮转：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。(不会饥饿，分时系统)<br>
多级反馈队列（有点复杂，就不写了）：<br>
实时调度：</p>
<h2 id="43-死锁简介">4.3 死锁简介</h2>
<p>资源（理解）<br>
在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推<br>
进的现象，就是“死锁”发生死锁后若无外力干涉，这些进程都将无法向前推进。</p>
<p>死锁产生的原因和必要条件（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597567271816.png" alt="" loading="lazy"><br>
原因：对系统资源的竞争、程序推进顺序不合法、信号量使用不当</p>
<p>死锁的表示方法和判定（理解）<br>
系统资源分配图，请求边、分配边，进程节点和资源节点</p>
<h2 id="44-死锁预防理解">4.4 死锁预防（理解）</h2>
<p>破坏“请求和保持”条件：要求进程一次性申请所有资源，操作系统阻塞进程直到其所有资源申请得到满足<br>
破坏“不剥夺“条件<br>
破坏”循环等待“条件<br>
破坏”互斥访问“条件（一般不用）</p>
<h2 id="45-死锁避免掌握">4.5 死锁避免（掌握）</h2>
<p>安全状态：存在安全序列就ok，死锁一定是不安全状态、不安全状态不一定死锁<br>
银行家算法数据结构、流程<br>
安全性算法</p>
<h2 id="46-死锁检测和恢复理解">4.6 死锁检测和恢复（理解）</h2>
<p>解除死锁：<br>
1.资源剥夺法<br>
2.撤销进程法<br>
2.进程回退法</p>
<h1 id="第5章-内存管理">第5章 内存管理</h1>
<h2 id="51-概述理解">5.1 概述（理解）</h2>
<p>存储层次结构<br>
存储管理的目的和任务：1.内存分配 2.地址映射 3.内存共享与保护 4.内存扩充</p>
<h2 id="52-地址重定位理解">5.2 地址重定位（理解）</h2>
<p>重定位的基本概念：因为逻辑地址与物理地址不一样<br>
静态重定位：在程序执行之前<br>
动态重定位：在程序执行过程中，需要重定位寄存器<br>
补充：程序的装入、程序的链接</p>
<h2 id="53-分区存储管理连续分配">5.3 分区存储管理（连续分配）</h2>
<p>注意：内部碎片：分配给某进程的内存区域中，某些没有用上的部分<br>
外部碎片：内存中某些空闲分区太小难以利用</p>
<p>单一连续：任何时刻内存中只能能有一道用户程序<br>
固定分区、可变分区分配（理解）</p>
<p>分区分配算法（掌握）<br>
首次适应算法：从低地址开始查找，找到第一个能满足大小的空闲分区<br>
最佳适应算法：<br>
最坏适应算法：<br>
循环首次适应算法：<br>
补充：哈希算法、伙伴系统（理解）</p>
<h2 id="54-页式存储管理非连续分配">5.4 页式存储管理（非连续分配）</h2>
<p>页：把用户进程的地址空间分为与物理块大小相等的一个个区域，称为页或页面<br>
页号=逻辑地址/页面长度(取除法的整数部分)<br>
页内偏移量=逻辑地址%页面长度(取除法的余数部分)<br>
<img src="https://lyhlyhaa.github.io/post-images/1597756802838.png" alt="" loading="lazy"><br>
块：内存等分称为块<br>
页表（每一个进程有自己的页表）、地址结构、</p>
<p>分页地址变换、<img src="https://lyhlyhaa.github.io/post-images/1597755784851.png" alt="" loading="lazy"><br>
页表长度表示有多少个页<br>
<em><strong>页表项是指页表中的一行？</strong></em><br>
快表（掌握）考察访问时间<br>
通常系统中，先访问快表，未命中时再访问内存；在有些系统中，快表与内存的访问同时进行，当快表命中时就停止对内存的访问。这里题目未具体指明，我们按照前者进行计算。但如果题中有具体的说明，计算时则应注意区别。<br>
计算过程：[(0.2+1)×85%+(0.2+1+1)×(1-85%)]μs=1.35μs。</p>
<p>两级页表、多级页表（理解）</p>
<h2 id="55-段式与段页式存储管理">5.5 段式与段页式存储管理</h2>
<p>段、段表、地址结构、分段地址变换（掌握）<br>
段的逻辑地址由段号和段内地址所组成。<br>
每个段在表中占有一个表项，其中记录了该段在内存中的起始地址（基址）和段的长度（段长）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597980322934.png" alt="" loading="lazy"><br>
分页和分段的区别（掌握）<br>
(1) 页是信息的物理单位，仅仅是出于系统管理的需要；段是信息的逻辑单位，其目的是满足用户的需要。<br>
(2) 页的大小固定且由系统确定，一个系统只能有一种大小的页面；段的长度不固定，决定于用户所编写的程序；<br>
(3) 分页的作业地址空间是一维的；分段的作业地址空间是二维的。<br>
(4) 通常分段的段内空间会比分页的页面空间大，因此段表会比页表短。</p>
<p>段页式存储管理（理解）</p>
<h2 id="56-内存扩充技术了解">5.6 内存扩充技术（了解）</h2>
<p>覆盖、交换</p>
<h2 id="57-虚拟存储管理">5.7 虚拟存储管理</h2>
<p>基本原理：局部性原理、虚拟存储器（理解）<br>
(1) 时间局限性。程序中的某条指令被执行，不久后会再次执行；某个数据被访问，不久后将再次被访问。产生时间局限性的典型原因是在程序中存在着大量的循环操作。<br>
(2) 空间局限性。 程序访问了某个存储单元，不久后，其附近的存储单元也将被访问。</p>
<p>请求分页存储管理（理解）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597822969611.png" alt="" loading="lazy"><br>
页面置换算法：<br>
最佳置换：每次选择淘汰的页面将是以后永不使用，或者再最长时间内不再被访问的页面，这样可以保证最低的缺页率。（无法实现，用来衡量算法好坏）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597826381870.png" alt="" loading="lazy"><br>
先进先出置换算法（FIFO）：每次淘汰的页面是最早进入内存的页面，可能有beledy异常<br>
最近最久未使用置换算法（LRU）：每次淘汰的页面时最近最久未使用的页面（逆向扫描😕，实现开销比较大，性能好）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597825736996.png" alt="" loading="lazy"><br>
时钟置换算法（CLOCK）：<br>
第二次机会（NRU），就是第二个：<br>
请求分页存储管理系统性能分析：缺页率、抖动、页面大小（理解）<br>
缺页率：缺页中断次数/总次数；<br>
抖动：如此频繁地更换页面，以至一个进程在运行中，将把大部分时间花在完成页面置换的工作上，我们称该进程发生了“抖动”。抖动现象分为局部抖动和全局抖动两种类型。</p>
<p>请求分段存储管理（理解）</p>
<h1 id="第6章-设备管理">第6章 设备管理</h1>
<h2 id="61-概述理解">6.1 概述（理解）</h2>
<p>设备管理的的目标和任务<br>
I/O系统结构：<br>
I/O设备分为机械部件和电子部件（I/O控制器，一个可以控制多个设备）<br>
I/O设备分类</p>
<h2 id="62-io系统控制方式掌握">6.2 I/O系统控制方式（掌握）</h2>
<p>程序直接控制方式<br>
中断控制方式<img src="https://lyhlyhaa.github.io/post-images/1597894847490.png" alt="" loading="lazy"><br>
DMA控制方式<img src="https://lyhlyhaa.github.io/post-images/1597895507112.png" alt="" loading="lazy"><br>
通道控制方式<img src="https://lyhlyhaa.github.io/post-images/1597895746989.png" alt="" loading="lazy"></p>
<h2 id="63-io软件的组成">6.3 I/O软件的组成</h2>
<p>I/O软件设计目标和原则（理解）<br>
I/O软件结构（理解）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597910317722.png" alt="" loading="lazy"><br>
设备驱动程序（了解）<br>
I/O设备的控制方式（掌握）<br>
设备无关软件（了解）<br>
用户层软件：<br>
SPOOLing技术（假脱机技术）的引入、组成和特点（理解）<br>
所谓脱机就是脱离主机控制的输入输出<br>
<img src="https://lyhlyhaa.github.io/post-images/1597911772456.png" alt="" loading="lazy"></p>
<h2 id="64-具有通道的设备管理">6.4 具有通道的设备管理</h2>
<p>通道类型（掌握）</p>
<h2 id="65-设备管理相关技术">6.5 设备管理相关技术</h2>
<p>DMA（理解）<br>
缓冲技术：<br>
缓存区作用：<br>
（1）可以改善CPU与I/O设备间速度不匹配的矛盾。<br>
（2）可以减少对 CPU的中断频率，放宽对中断响应时间的限制。<br>
（3）可以提高 CPU和 I/O设备之间的并行性。<br>
<img src="https://lyhlyhaa.github.io/post-images/1597913868957.png" alt="" loading="lazy"><br>
单缓冲（一个缓冲区）、双缓冲（两个缓冲）、循环缓冲区和缓冲池（理解）</p>
<p>总线技术（不考）</p>
<h2 id="66-磁盘存储管理">6.6 磁盘存储管理</h2>
<p>磁盘简述：磁盘的定义、组成、磁盘访问时间（理解）<br>
磁盘调度：FCFS、SSTF、SCAN、C-SCAN、N步扫描、F-SCAN（掌握）<br>
磁盘管理（不考）<br>
容错技术：容错技术的概念、廉价磁盘冗余阵列（理解）</p>
<h1 id="第7章-文件管理">第7章 文件管理</h1>
<p>7.1 概述（理解）<br>
文件、文件系统的定义<br>
7.2 文件结构<br>
逻辑结构（理解）<br>
索引文件，<img src="https://lyhlyhaa.github.io/post-images/1597930086320.png" alt="" loading="lazy"><br>
物理结构：顺序结构、链接结构、索引结构（掌握）；<br>
直接文件、哈希文件（理解）<br>
7.3 文件目录<br>
文件控制块FCB（掌握）<br>
为了实现按名存取，一个文件对应一个FCB，一个FCB就是一个目录项，多个FCB组成文件目录<br>
索引节点（掌握）：把文件控制块中除了文件名之外的文件描述信息放到一个索引结点指针中，加快了文件检索速度<br>
目录结构：单级（只有一个目录表）、两级（两个）和多级（多个）（了解）<br>
目录查询（了解）<br>
绝对路径：从根目录出发 相对路径：从当前目录出发<br>
7.4 文件共享和安全（理解）<br>
文件共享：符号链接实现共享、索引节点实现共享（理解）<br>
文件安全：存取控制矩阵、存取控制表、用户权限表、口令方法（了解）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1286 比赛]]></title>
        <id>https://lyhlyhaa.github.io/post/1286-bi-sai/</id>
        <link href="https://lyhlyhaa.github.io/post/1286-bi-sai/">
        </link>
        <updated>2020-07-30T08:24:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>有n名选手参加比赛，从1∼n编号。每场比赛由两位选手对决，失败的被淘汰。为了增加比赛的观赏性，举办方并不想比赛双方实力相差太大的，所以决定，每场比赛的两位选手，之前胜场次数之差不能超过1。同时，鸡贼的举办方又不想冠军选手比赛太少了（严重影响比赛收入），希望冠军选手比赛场次越多越好。作为选手的你，当然不希望夺冠路上比赛场次太多，请问在这个赛制下，冠军最多比赛多少场？</p>
<h2 id="输入">输入</h2>
<p>存在不超过10000组样例。每行一个整数n(1≤n≤1018)。</p>
<h2 id="输出">输出</h2>
<p>每行输出一个样例的结果，为一个整数。</p>
<h2 id="样例输入">样例输入</h2>
<p>1<br>
2<br>
3<br>
10<br>
1000000000000000000</p>
<h2 id="样例输出">样例输出</h2>
<p>0<br>
1<br>
2<br>
4<br>
85</p>
<hr>
<p>全部比赛看作一棵树<br>
<img src="https://lyhlyhaa.github.io/post-images/1596097884622.jpg" alt="" loading="lazy"><br>
n 很容易看出来是一个斐波那契数列，之后设置一个数组记录，很容易就完成了<br>
g(1)=1   g(2)=2<br>
g(h)=g(h-1)+g(h-2)<br>
<img src="https://lyhlyhaa.github.io/post-images/1596098127037.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小生成树]]></title>
        <id>https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/">
        </link>
        <updated>2020-07-26T07:00:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="克鲁斯卡尔算法">克鲁斯卡尔算法：</h1>
<p>1.把边进行排序，按从从小到大的顺序。<br>
2.贪心算法，找未加入通路的权值最小的边<br>
3.判断是否形成环，如果形成，则跳过这一条边，返回第二步，如果没有，则把找到的边加入通路中，返回第二步<br>
4.当通路中的的边的个数等于点的个数-1，则最小生成树已经形成。</p>
<p><em>排序可以用sort函数，边的存储可以用结构体数组</em><br>
<strong>主要是判断是否形成环：</strong><br>
使用<a href="https://blog.csdn.net/qq_41593380/article/details/81146850">并查集</a><br>
<strong>初始化</strong></p>
<pre><code>void init(int n)
{
    for (int i = 1; i &lt;= n; ++i)
        fa[i] = i;
}
</code></pre>
<p><strong>路径压缩查找</strong></p>
<pre><code>int find(int x)
{
    return x == fa[x] ? x : (fa[x] = find(fa[x]));//
}
</code></pre>
<p><strong>合并</strong></p>
<pre><code>ivoid merge(int i, int j)
{
    fa[find(i)] = find(j);
}//合并
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐波拉契数列]]></title>
        <id>https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/</id>
        <link href="https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/">
        </link>
        <updated>2020-07-24T07:30:17.000Z</updated>
        <content type="html"><![CDATA[<p>。。。。<br>
今晚整理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[骨牌问题（铺地砖）]]></title>
        <id>https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/</id>
        <link href="https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/">
        </link>
        <updated>2020-07-24T07:14:41.000Z</updated>
        <content type="html"><![CDATA[<p>暂时看一下别的博客（https://blog.csdn.net/xiangAccepted/article/details/80229187?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三色旗问题]]></title>
        <id>https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/</id>
        <link href="https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/">
        </link>
        <updated>2020-07-24T02:54:57.000Z</updated>
        <content type="html"><![CDATA[<p>要用到三个指针：一个前指针begin，一个中指针current，一个后指针end，current指针遍历整个数组序列，当</p>
<p>current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ；<br>
current指针所指元素为1时，不做任何交换（即球不动），而后current++ ；<br>
current指针所指元素为2时，与end指针所指的元素交换，而后，current指针不动，end-- 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络（考试）]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-suan-ji-wang-luo/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-suan-ji-wang-luo/">
        </link>
        <updated>2020-07-23T08:31:33.000Z</updated>
        <content type="html"><![CDATA[<p><em>图文无关😂</em></p>
<hr>
<h1 id="概论">概论</h1>
<p>OSI分层<br>
<img src="https://lyhlyhaa.github.io/post-images/1597219135928.png" alt="" loading="lazy"><br>
前四层，端到端；后三层，点到点</p>
<p>五层模型：应用层、传输层、网络层、链路层、物理层</p>
<figure data-type="image" tabindex="1"><img src="https://lyhlyhaa.github.io/post-images/1597239423967.png" alt="" loading="lazy"></figure>
<p>计算机网络的三个组成部分是主机、通信子网和协议</p>
<p>速率：速率即数据率或称数据传输率或比特率（换算时是以10的三次方换算）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597219935014.png" alt="" loading="lazy"></p>
<p>带宽：计算机网络中表示网络的通信线路传送数据的能力（其实指的就是在链路的入口主机发送数据的速率，而不是在链路上的速率）</p>
<p>吞吐量：表示在单位时间内通过某个网络（或信道、接口）的数据量。单位b/s,kb/s,Mb/s</p>
<p>时延<img src="https://lyhlyhaa.github.io/post-images/1597221924901.png" alt="" loading="lazy"><br>
所谓高速链路只改变发送时延</p>
<p>时延带宽积：传播时延 x 带宽</p>
<p>RTT(往返时延)：从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，<br>
总共经历的时延。</p>
<p>面向连接三个阶段：建立连接   通信（数据传输） 释放连接</p>
<h1 id="物理层">物理层</h1>
<p>特性：<br>
1.机械特性 （比如器件尺寸）2.电气特性（电压范围） 3.功能特性（某种电平意义） 4.规程特性（又名过程特性）（不同功能的各种事件出现顺序）</p>
<p>通信交互方式：<br>
单工（单向通信，一条信道）、半双工（双向交替通信，两条信道）、全双工（双向同时通信，两条信道）</p>
<p>码元（ code）：<br>
在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。（码元离散状态有M种称为M进制码元）</p>
<figure data-type="image" tabindex="2"><img src="https://lyhlyhaa.github.io/post-images/1597324427854.png" alt="" loading="lazy"></figure>
<p>调制：<br>
1.基带调制（编码）：不归零制、归零制、曼切斯特编码、差分曼切斯特编码<br>
2.带通调制（转化为模拟信号）：调幅、调频、调相</p>
<p><img src="https://lyhlyhaa.github.io/post-images/1597461915732.png" alt="" loading="lazy"><br>
<strong>注意只有在奈式准则和香农定理中带宽才用Hz</strong></p>
<p>香农定理：<br>
<img src="https://lyhlyhaa.github.io/post-images/1597484235197.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1597479421625.png" alt="" loading="lazy"></p>
<p><img src="https://lyhlyhaa.github.io/post-images/1597480711254.png" alt="" loading="lazy"><br>
导向型：双绞线、同轴电缆、光纤</p>
<p>物理层设备：中继器、集线器（再生、放大信号，星型拓扑、不具备定向传输功能，不能分割冲突域）</p>
<p>信道复用：<br>
频分复用：用户再分配到一定的频带后，在通信过程中至始至终都占据这个频带；（并行）<br>
时分复用（TDM）：将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。（并发，类似于时间片）<br>
统计时分复用STDM：（谁来给谁分配时间片，不是无脑每个人都给）<br>
波分复用：就是光的频分复用<br>
码分复用：<br>
每个站被指派一个唯一的 m bit 码片序列。<br>
如发送比特 1，则发送自己的 m bit 码片序列，如发送比特 0，则发送该码片序列的二进制反码<br>
为表示方便，将0写为-1，1写为+1<br>
<strong>注意：两个不同站的码片序列正交</strong><br>
不同站的码片向量规格化内积为0**（规格化内积，对应位相乘之后相加，除以位数m）**<br>
任何一个码片向量和该码片向量自己的规格化内积都是1 。一个码片向量和该码片反码的向量的规格化内积值是 –1<br>
合并：各路数据在信道中线性相加；分离：合并的数据和源站规格化内积</p>
<h1 id="数据链路层">数据链路层</h1>
<p>结点:主机、路由器<br>
链路:网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。<br>
数据链路:网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。<br>
帧:链路层的协议数据单元，封装网络层数据报。</p>
<p>封装成帧、<br>
透明传输：字符填充法：转义字符ESC，开始SOH，结束EOT（<s>ETO，你被捕了，哈哈哈</s>）<br>
零比特填充法</p>
<p><strong>差错控制：有比特错和帧错两种，这里我们讨论比特错</strong><br>
检错编码：<br>
<img src="https://lyhlyhaa.github.io/post-images/1597982457147.png" alt="" loading="lazy"><br>
奇偶校验码：在传输的信息元前面加一位校验元（0 or 1），使1的个数为奇数或者偶数，检查收到的信息中1的个数是否与发送的相同（加了校验元后的）   特点：只能查出奇数个比特错误、检错能力为50%<br>
<img src="https://lyhlyhaa.github.io/post-images/1598061552412.png" alt="" loading="lazy"></p>
<p>纠错编码：海明码：<br>
<img src="https://lyhlyhaa.github.io/post-images/1598063025567.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1598063088754.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1598063184760.png" alt="" loading="lazy"><br>
检验纠错：<img src="https://lyhlyhaa.github.io/post-images/1598063292458.png" alt="" loading="lazy"></p>
<p><strong>流量控制：</strong>（在链路层窗口大小是确定的）<br>
链路层实现方法：接收方收不下就不回复确认</p>
<pre><code>停止等待协议：每发送一个帧之后发送，等待对方的确认，就停止收到确认之后再发送下一个
信道利用率：发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率。发送时间/（发送时间+往返时间RTT+接收时间）
信道吞吐率=信道利用率*发送方的发送速率

</code></pre>
<p><em>滑动窗口协议：</em></p>
<pre><code>后退N帧协议（GBN）：
1.累积确认（偶尔捎带确认）
2.接收方只按顺序接收帧，不按序无情丢弃
3.确认序列号最大的、按序到达的帧
4.发送窗口最大为2n-1，接收窗口大小为1
Go-back-N策略的基本原理：当接收方检测出失序的信息后，要求发送方重发最后一个正确接受的信息帧之后的所有未被确认的帧

选择重传协议SR
1.对数据帧逐一确认，收一个确认一个
2.只重传出错帧
3.接收方有缓存
4.发送窗口=接收窗口，小于或等于序号空间大小的一半

</code></pre>
<p>两种链路：<br>
点对点链路：两个相邻节点通过一条链路相连，应用：PPP协议，常用于广域网<br>
广播式链路：常用于局域网，典型拓扑结构：总线型、星型（逻辑总线型）</p>
<p><strong>以太网：无连接、不可靠</strong><br>
MAC地址：48位二进制地址，前24位代表厂家<br>
CSMA/CD：争用期<img src="https://lyhlyhaa.github.io/post-images/1598089775570.png" alt="" loading="lazy"><br>
最小帧长：2τ *数据传输速率</p>
<p><strong>广域网</strong><br>
ppp协议（只支持全双工链路）<br>
<img src="https://lyhlyhaa.github.io/post-images/1598148331247.png" alt="" loading="lazy"><br>
除了字节填充，还可以采用零比特填充（当采用同步传输，即一连串的比特连续发送）<br>
出现五个连续1，则立即填入一个0<br>
地址字段A和控制字段C实践上不带信息，可通过协商取消</p>
<p>HDLC协议：0比特插入法</p>
<p><strong>链路层设备</strong>：网桥&amp;交换机（分割冲突域，不能分割广播域）<br>
网桥根据MAC帧的目的地址对帧进行转发和过滤<br>
自学习：每个设备都发一次信息，就可以形成一个完整的转发表<br>
直接连接在交换机的设备独占带宽</p>
<p>交换机可提供的最大带宽：端口数*相应端口速率*2（全双工模式）<br>
物理层扩充以太网：使用集线器，集线器之间最远距离为100米（使用双绞线），主机与集线器的最远距离为100米</p>
<pre><code>不可能发生冲突的MAC协议有 CDMA   TDMA     FDMA
IEEE802.11g标准使用了IEEE802.11a的OFDM调制技术，和IEEE802.11b一样运行在2.4GHz的ISM频段内，理论速度可达54Mbps。

</code></pre>
<h1 id="网络层">网络层</h1>
<pre><code>传输单位为数据报
IP协议可将源主机的IP数据报分片后进行传输，在到达目的主机之前，在传输过程中可能再次分片，但是不会重组。
提供无连接、尽最大努力交付（不可靠）的数据报服务
</code></pre>
<p><strong>数据交换</strong><br>
电路交换： 建立连接（呼叫/电路建立） -&gt; 通信 -&gt; 释放连接（拆除电路）<br>
传输时延最小<br>
数据量大，传送时间远大于呼叫时间则采用电路交换<br>
特点：独占资源（但是又有多路复用？什么东西！！！）</p>
<p>报文交换：<br>
类似分组交换，不过不分组<br>
分组交换：<br>
<img src="https://lyhlyhaa.github.io/post-images/1598153522928.png" alt="" loading="lazy"><br>
计算题中要注意的几点:<br>
1.单位换算:b/B,Mbps,kbps<br>
2是否考虑传播延迟<br>
3.时间至少是多少—选择最少跳数<br>
4.起始时间（从发送开始到接收完为止/从发送开始到发送完毕）<br>
5.是否有分组头部大小的开销<br>
6.报文交换时延更长，分组交换时延可能不是整数</p>
<p><img src="https://lyhlyhaa.github.io/post-images/1598155426118.png" alt="" loading="lazy"><br>
虚电路：建立连接（虚电路建立）-&gt; 数据传输  -&gt; 释放连接（虚电路释放）</p>
<p><code>数据链路层：MTU（最大传送单元）：以太网规定为1500字节，包含数据链路层以上所有数据</code></p>
<p>IP数据报格式：<img src="https://lyhlyhaa.github.io/post-images/1598185535426.png" alt="" loading="lazy"></p>
<pre><code>标识：同一数据报的分片使用同一标识。
标志只有2位有意义x _ _
中间位DF (Don't Fragment) :
DF=1，禁止分片
DF=0，允许分片
最低位MF (More Fragment) :
MF=1，后面“还有分片”
MF=0，代表最后一片/没分片
片偏移:指出较长分组分片后，某片在原分组中的相对位置。以8B为单位。
除了最后一个分片，每个分片长度一定是8B的整数倍。
</code></pre>
<p>IP地址：全世界唯一的32位/4字节标识符，标识路由器主机的接口<br>
&lt;网络号，主机号&gt;<br>
特殊IP地址：<br>
<img src="https://lyhlyhaa.github.io/post-images/1598175646432.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1598175981780.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1600565949484.png" alt="" loading="lazy"></p>
<p>子网掩码：<br>
网络号全1，子网号全1，主机号全0<br>
与IP地址逐位相与（即只有1与1才返回1）就可以得到子网的网络地址</p>
<p>无分类编制CIDR<br>
1.消除了传统A类、B类和C类以及划分子网的概念<br>
2.把网络前缀都相同的IP地址组成一个CIDR地址块<img src="https://lyhlyhaa.github.io/post-images/1598186496327.png" alt="" loading="lazy"></p>
<p><code>最长前缀匹配：使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体</code></p>
<p>ARP协议（完成主机或路由器IP地址到MAC地址的映射，解决下一跳走那的）：<br>
先检查ARP高速缓存；<br>
<img src="https://lyhlyhaa.github.io/post-images/1598236165572.png" alt="" loading="lazy"><br>
同一网段内（网络号相同）：直接广播找MAC地址<br>
不是同一网段内：先找默认网关MAC地址，发到路由器</p>
<p>ICMP协议<br>
<code>注意：ICMP差错报告报文在**IP数据报的数据部分**</code><br>
不发送ICMP差错报文的情况<br>
<img src="https://lyhlyhaa.github.io/post-images/1598238808462.png" alt="" loading="lazy"><br>
<code>组播一点对多点，而不是广播向所有</code><br>
ICMP询问报文<br>
<img src="https://lyhlyhaa.github.io/post-images/1598238725933.png" alt="" loading="lazy"></p>
<pre><code>DHCP协议
动态主机配置协议DHCP是应用层协议，使用客户/服务器方式，客户端和服务端通过广播方式进行交互，基于UDP。
DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与P地址，
允许地址重用，支持移动用户加入网络，支持在用地址续租。
1.主机广播DHCP发现报文(DHCPDISCOVER)
2.DHCP服务器广播DHCP提供报文(DHCPOFFER)
3.主机广播DHCP请求报文(DHCPREQUEST)
4.DHCP服务器广播DHCP确认报文(DHCPACK)
</code></pre>
<hr>
<p><strong>路由算法</strong><br>
<img src="https://lyhlyhaa.github.io/post-images/1598240383909.png" alt="" loading="lazy"><br>
<code>一个自治系统AS内的路由器不能完成强制的选择寻找路由</code><br>
RIP（应用层协议，采用UDP协议）<br>
<img src="https://lyhlyhaa.github.io/post-images/1598254304064.png" alt="" loading="lazy"><br>
距离向量算法<br>
<img src="https://lyhlyhaa.github.io/post-images/1598242047926.png" alt="" loading="lazy"><br>
慢收敛导致路由器接受了无效路由信息</p>
<p>OSPF（开放最短路径优先），内部网关协议<br>
使用链路状态路由算法<br>
交换内容：与本路由器相邻的所有路由器的链路状态</p>
<p>BGP（应用层协议，借助TCP传送），外部网关协议<br>
使用路径-向量算法<br>
交换内容：<br>
首次：整个路由表<br>
非首次：有变化的部分</p>
<hr>
<p>IPv6<br>
<img src="https://lyhlyhaa.github.io/post-images/1598256461195.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1598256909154.png" alt="" loading="lazy"></p>
<p>IP多播<br>
硬件组播</p>
<p>网络层设备：路由器（包含数据链路层、物理层）</p>
<h1 id="传输层">传输层</h1>
<p>传输单位：报文段<br>
功能：<br>
1.提供进程与进程之间的逻辑通信<br>
2.复用与分用</p>
<pre><code>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。
UDP的主要特点:
1.UDP是无连接的，减少开销和发送数据之前的时延。
2.UDP使用最大努力交付，即不保证可靠交付。
3.UDP是面向报文的，适合一次性传输少量数据的网络应用。
4.UDP无拥塞控制，适合很多实时应用。
5.首部开销小，8B，TCP20B
(转化UDP数据报首部时，将每一位都先转化为二进制，然后转化十进制)
例：一个UDP用户数据报的首部的十六进制表示是0632  0045  001C  E217。
在UDP首部中，源端口占2个字节，即06 32 ，化为十进制是1586.
目的端口占2字节，即00 45 ，化为十进制是69.
用户数据报总长度也占2个字节，即00 1C ,十进制为：28。
数据部分为数据报总长度减去首部长度8字节，28-8=20。
此UDP用户数据报是从客户发给服务器（因为目的端口号&lt;1023，是熟知端口）
</code></pre>
<p><img src="https://lyhlyhaa.github.io/post-images/1598348556647.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1600521483569.png" alt="" loading="lazy"></p>
<hr>
<p>TCP报文段首部格式<br>
<img src="https://lyhlyhaa.github.io/post-images/1598496734676.png" alt="" loading="lazy"></p>
<pre><code>序号:在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。
确认号:期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。
数据偏移（首部长度）:TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B位单位，即1个数值是4B。

紧急位URG: URG=1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。
确认位ACK:ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。
同步位SYN:SYN=1时，表明是一个连接请求/连接接受报文。
终止位FIN:FIN=1时，表明此报文段发送方数据己发完，要求释放连接。
推送位PSH:PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。
复位RST:RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。

窗口:指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。
检验和:检验首部+数据，检验时要加上12B伪首部，第四个字段为6。
紧急指针:URG=1时才有意义，指出本报文段中紧急数据的字节数。
选项:最大报文段长度MSS、窗口扩大、时间截、选择确认...

</code></pre>
<p>可靠传输：<br>
1.校验 2.序号 3.确认 4.重传<br>
累计确认：</p>
<pre><code>冗余ACK（冗余确认）
每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。
发送方已发送1，2，3，4，5报文段
接收方收到1，返回给1的确认（确认号为2的第一个字节）
接收方收到3，仍返回给1的确认（确认号为2的第一个字节）
接收方收到4，仍返回给1的确认（确认号为2的第一个字节)
接收方收到5，仍返回给1的确认（确认号为2的第一个字节)
发送方收到3个对于报文段1的冗余ACK一认为2报文段丢失，重传2号报文段快速重传
</code></pre>
<p>超时重传：重传时间的确定，采用自适应算法，动态改变重传时间RTTs<br>
三次握手（TCP连接建立）：<br>
<img src="https://lyhlyhaa.github.io/post-images/1598500308347.png" alt="" loading="lazy"><br>
四次握手（TCP连接释放）<br>
<img src="https://lyhlyhaa.github.io/post-images/1598500673688.png" alt="" loading="lazy"></p>
<hr>
<p>流量控制：让发送方慢点，让接收方可以<br>
在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd(接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。<br>
<img src="https://lyhlyhaa.github.io/post-images/1598516547012.png" alt="" loading="lazy"></p>
<p><code>拥塞控制和流量控制区别，拥塞控制是整个网络中数据太多导致发送的数据迟迟到不了目的地，是全局性问题，而流量控制是点对点的问题</code></p>
<p>TCP拥塞控制(防止过多的数据注入到网络中)<br>
慢开始和拥塞避免：<img src="https://lyhlyhaa.github.io/post-images/1598530881385.png" alt="" loading="lazy"><br>
快重传和快恢复：<img src="https://lyhlyhaa.github.io/post-images/1598531031133.png" alt="" loading="lazy"></p>
<h1 id="应用层">应用层</h1>
<p>两种网络模型：c/s 客户/服务器模型；p2p模型</p>
<p>域名：越右边越高，顶级域名  二级域名  三级域名等<br>
域名服务器：<br>
根域名服务器<br>
顶级域名服务器<br>
权限域名服务器（权威域名服务器）<br>
本地域名服务器</p>
<p>递归查询（一路查到底）、迭代查询（查一个回来一次）</p>
<p>FTP TFTP<br>
FTP使用TCP实现可靠传输<br>
控制连接（端口21，始终保持）和数据连接（，保持一会）</p>
<p>SMTP<br>
组成结构：用户代理、邮件服务器、协议<br>
用户代理---SMTP---邮件服务器--SMTP--邮件服务器---POP3---接收方<br>
使用TCP连接  端口号25   C/S方式<br>
MIME通用因特网邮件扩充：使支持多种类型数据传输</p>
<pre><code>读取邮件协议：
POP3邮局协议 ：TCP连接 端口号110  C/S；
网际报文存取协议IMAP：想下就下
</code></pre>
<p>基于万维网的电子邮件<br>
用户代理---HTTP---邮件服务器--SMTP--邮件服务器---HTTP---接收方</p>
<p>HTTP(HTTP协议是无状态的)<br>
统一资源定位符URL：唯一标识一个资源（文字、视频。<br>
URL一般形式:<br>
&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;http://www.pku.edu.cn<br>
http          域名<br>
ftp            IP地址</p>
<pre><code>输入URL后的过程：
1.浏览器分析URL
2.浏览器向DNS请求解析IP地址
3.DNS解析出IP地址
4.浏览器与服务器建立TCP连接
5.浏览器发出取文件命令
6.服务器响应
7.释放TCP连接
8.浏览器显示
</code></pre>
<p>HTTP格式<img src="https://lyhlyhaa.github.io/post-images/1598583730914.png" alt="" loading="lazy"><br>
状态码:<br>
1xx表示通知信息的，如请求收到了或正在处理。<br>
2xx表示成功，如接受或知道了。<br>
3xx表示重定向，如要完成请求还必须采取进一步的行动。<br>
4xx表示客户的差错，如请求中有错误的语法或不能完成。<br>
5xx表示服务器的差错，如服务器失效无法完成请求。</p>
<p>SNMP（网络管理协议）<br>
SNMP 报文使用 UDP 来传送  C/S方式 端口号161<br>
<img src="https://lyhlyhaa.github.io/post-images/1598603145090.png" alt="" loading="lazy"><br>
(1) T 字段，即标识符八位位组(identifier octet)，用于标识标记。<br>
(2) L 字段，即长度用八位位组(length octet)，用于标识后面 V 字段的长度。<br>
(3) V 字段，即内容八位位组(content octet)，用于标识数据元素的值。<br>
INTEGER 15，其 T 字段是02， INTEGER 类型要用 4 字节编码。最后得出 TLV 编码为 02 04 00 00 00 0F。<br>
又如 IPAddress 192.1.2.3，其 T 字段是 40，V 字段需要 4 字节表示，因此得出 IPAddress 192.1.2.3 的 TLV 编码是 40 04 C0 01 02 03</p>
<h1 id="网络安全">网络安全</h1>
<p>一般的数据加密模型 （即加密密钥与解密密钥是相同的密码体制。<br>
这种加密系统又称为对称密钥系统。）<br>
<img src="https://lyhlyhaa.github.io/post-images/1598600983595.png" alt="" loading="lazy"></p>
<p>数字签名<img src="https://lyhlyhaa.github.io/post-images/1598601806438.png" alt="" loading="lazy"></p>
<p>A向B发送消息Y，并使用公钥体制进行数字签名。 设私有密秘钥SKA和公开秘钥都PKA, E表示加密算法， D表示解密算法，则B要保留的证据是  DSKA(Y)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路径算法]]></title>
        <id>https://lyhlyhaa.github.io/post/zui-duan-lu-jing-suan-fa/</id>
        <link href="https://lyhlyhaa.github.io/post/zui-duan-lu-jing-suan-fa/">
        </link>
        <updated>2020-07-22T12:05:34.000Z</updated>
        <content type="html"><![CDATA[<p>说起来这个算法做过很多次了，学图论的时候写过实验报告，可是现在做题又给忘了，惭愧。</p>
<hr>
<h1 id="dijkstra算法">Dijkstra算法</h1>
<p>1.<strong>初始化</strong>:先找出从源点vo到各终点v的直达路径(Vo,Vk) ,<br>
即通过一条弧到达的路径。<br>
2.<strong>选择</strong>:从这些路径中找出一条长度最短的路径(Vo,u) 。<br>
3.<strong>更新</strong>:然后对其余各条路径进行适当调整:<br>
若在图中存在弧(u,Vk) ，且(V,U) + (u,Vk) &lt; (Vo,Vk),<br>
则以路径(Vo,U,Vk) 代替(Vo,Vk) 。<br>
在调整后的各条路径中，再找长度最短的路径，依此类推。<br>
设计一个s[]数组，来存已经在最短路径中的点</p>
]]></content>
    </entry>
</feed>