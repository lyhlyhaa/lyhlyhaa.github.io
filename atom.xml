<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lyhlyhaa.github.io</id>
    <title>混子协会会长</title>
    <updated>2020-08-30T09:18:44.628Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lyhlyhaa.github.io"/>
    <link rel="self" href="https://lyhlyhaa.github.io/atom.xml"/>
    <logo>https://lyhlyhaa.github.io/images/avatar.png</logo>
    <icon>https://lyhlyhaa.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 混子协会会长</rights>
    <entry>
        <title type="html"><![CDATA[数据库]]></title>
        <id>https://lyhlyhaa.github.io/post/shu-ju-ku/</id>
        <link href="https://lyhlyhaa.github.io/post/shu-ju-ku/">
        </link>
        <updated>2020-08-30T02:48:58.000Z</updated>
        <content type="html"><![CDATA[<pre><code>数据库管理系统（Database Management System，简称DBMS）管理数据库的系统软件，是数据库系统的核心组件。
</code></pre>
<p>数据库系统的特点<br>
数据结构化<br>
数据的共享性高，冗余度低且易扩充<br>
数据独立性高<br>
数据由数据库管理系统统一管理和控制</p>
<h3 id="数据模型的组成要素">数据模型的组成要素</h3>
<pre><code>数据结构 
数据操作 
数据完整性约束
</code></pre>
<h2 id="最常用的数据模型">最常用的数据模型</h2>
<h3 id="非关系模型">非关系模型</h3>
<h4 id="层次模型hierarchical-model">层次模型(Hierarchical Model)</h4>
<pre><code>层次模型用树形结构来表示各类实体以及实体间的联系，有且仅有一个根结点；
每个非根结点有且仅有一个父(直接上层)结点。它最适合表示实体的一对多联系。
</code></pre>
<h4 id="网状模型network-model">网状模型(Network Model)</h4>
<pre><code>通过网状结构表示实体及联系。“网”中每个结点表示一个实体(型)，结点之间箭头表示实体(型)间的联系。
网状数据模型主要特点：网状数据模型可能有多个根结点，某些非根结点可能有多个父结点，适合表示实体的多对多联系。
</code></pre>
<h3 id="关系模型relational-model">关系模型(Relational Model)</h3>
<h4 id="关系模型的组成">关系模型的组成</h4>
<h5 id="关系数据结构">关系数据结构</h5>
<pre><code>单一的数据结构----关系
现实世界的实体以及实体间的各种联系均用关系来表示
数据的逻辑结构----二维表
从用户角度，关系模型中数据的逻辑结构是一张二维表。
</code></pre>
<h5 id="关系操作集合">关系操作集合</h5>
<pre><code>插入、删除、修改、查询（选择、投影、连接、除、并、交、差）
</code></pre>
<h5 id="关系完整性约束">关系完整性约束</h5>
<pre><code>实体完整性、参照完整性、域完整性、用户定义完整性
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[逆序数]]></title>
        <id>https://lyhlyhaa.github.io/post/ni-xu-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/ni-xu-shu/">
        </link>
        <updated>2020-08-01T09:15:57.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/dlengong/article/details/7594919?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.channel_param">文章</a><br>
1.两层循环<br>
一猜就会超时，后来试了一下，果然。<br>
2.归并排序<br>
把数组分成两份，分别进行排序，然后合并<br>
会用到递归，从最开始的数组，到整个区间只有一个元素结束，即l==r<br>
<img src="https://lyhlyhaa.github.io/post-images/1596333420953.gif" alt="" loading="lazy"><br>
合并操作：<br>
<img src="https://lyhlyhaa.github.io/post-images/1596333135649.gif" alt="" loading="lazy"><br>
在两个分出来的数组比较完之后，把未填入的数组剩下的数依次（因为数组已经排好序）填入</p>
<pre><code>while(i&lt;=mid) temp[k++] = a[i++];  
while(j&lt;=right) temp[k++] = a[j++];
</code></pre>
<p>用归并求逆序数的关键就在于<br>
Seq1：3  4  5<br>
Seq2：2  6  8  9<br>
合并成一个有序序:</p>
<p>Seq：2  3  4  5  6  8  9</p>
<p>对于序列seq1中的某个数a[i],序列seq2中的某个数a[j]，如果a[i]&lt;a[j],没有逆序数，如果a[i]&gt;a[j]，那么逆序数为seq1中a[i]后边元素的个数(包括a[i])，即len1-i+1,<br>
3.<a href="http://www.cppblog.com/Ylemzy/articles/98322.html">树状数组</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统]]></title>
        <id>https://lyhlyhaa.github.io/post/cao-zuo-xi-tong/</id>
        <link href="https://lyhlyhaa.github.io/post/cao-zuo-xi-tong/">
        </link>
        <updated>2020-08-01T02:21:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第1章-操作系统概述">第1章 操作系统概述</h1>
<h2 id="11-什么是操作系统">1.1 什么是操作系统</h2>
<p><em>操作系统的定义（掌握）</em><br>
操作系统是计算机系统中最基础，最重要的<strong>系统软件</strong>，是其他软件的支撑软件。<br>
<em>计算机系统的组成（理解）</em><br>
采用冯诺依曼体系结构，由运算器、控制器、存储器、输入输出（I/O）设备五大部件组成。<br>
<em>操作系统与计算机系统（理解）</em><br>
计算机系统由软件、硬件和数据三部分组成，操作系统是配置在计算机硬件上的第一层软件。</p>
<h2 id="12-操作系统的发展过程理解">1.2 操作系统的发展过程（理解）</h2>
<p>简单计算机系统（无操作系统）：用户独占操作系统、<br>
单道批处理系统：自动性、顺序性和单道性（内存中只允许一道程序）、<br>
多道批处理系统：交替执行<img src="https://lyhlyhaa.github.io/post-images/1596942394126.png" alt="" loading="lazy"><br>
<code>允许多个用户将若干作业提交给计算机脱机处理的操作系统是多道批处理系统</code><br>
宏观并行，微观串行，多道性<br>
分时系统：交互性、及时性、独立性、多路性<br>
<strong>批处理系统、分时系统的出现标志着操作系统的形成</strong><br>
实时系统：及时性、交互性、独立性、多路性和高可靠性</p>
<h2 id="并行是指两个或者多个事件在同一时刻发生而并发是指两个或多个事件在同一时间间隔内发生-13-操作系统的主要功能掌握"><strong>并行是指两个或者多个事件在同一时刻发生;而并发是指两个或多个事件在同一时间间隔内发生。</strong>*<br>
1.3 操作系统的主要功能（掌握）</h2>
<p>处理机管理：进程控制、进程同步、进程通信和进程调度<br>
存储器管理：内存分配、内存保护、地址映射、内存扩充<br>
设备管理：缓冲区管理、设备分配、设备处理、虚拟设备管理<br>
文件管理：<br>
及用户接口：命令接口、程序接口、图形接口<br>
<code>基本特征:并发性、共享性、虚拟性 、异步性</code></p>
<h1 id="第2章-中断">第2章 中断</h1>
<h2 id="21-中断的基本概念理解">2.1 中断的基本概念（理解）</h2>
<p>目态（用户态，权限低） 管态（核心态）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597117788357.png" alt="" loading="lazy"><br>
中断的作用、中断类型、中断嵌套、中断优先级和中断屏蔽<br>
中断寄存器（每个中断源都有，中断发生时的相关信息记录在该存储器中）、<br>
程序状态字（PSW）：</p>
<h2 id="22-中断在操作系统中的地位了解">2.2 中断在操作系统中的地位（了解）</h2>
<p>中断是多道程序并发执行的推动力<br>
操作系统是由中断驱动的</p>
<h2 id="23-中断响应过程理解">2.3 中断响应过程（理解）</h2>
<h2 id="24-中断处理过程掌握">2.4 中断处理过程（掌握）</h2>
<p>中断处理流程、中断服务程序</p>
<h2 id="25-向量中断了解">2.5 向量中断（了解）</h2>
<h1 id="第3章-进程描述和控制">第3章 进程描述和控制</h1>
<h2 id="31-进程概述">3.1 进程概述</h2>
<p>程序的顺序执行及其特征（理解）<br>
程序的并发执行及其特征（理解）<br>
进程的概念及其特征（掌握）<br>
程序是完成特定任务的一组指令的结合，可以永久保存，具有静态性；<br>
进程是程序在某一数据结构上的一次执行过程，是系统进行资源分配和调度的基本单位，具有动态性；<br>
一个进程可以包含多个程序，一个程序也可以被多个进程执行。</p>
<p><strong>动态性</strong><br>
进程状态（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597134258032.png" alt="" loading="lazy"><br>
进程控制块（理解）PCB<br>
PCB是进程的唯一标识符</p>
<h2 id="32-进程控制理解">3.2 进程控制（理解）</h2>
<p>进程创建和终止<br>
进程阻塞和唤醒<br>
进程挂起和激活<br>
<img src="https://lyhlyhaa.github.io/post-images/1597136342534.png" alt="" loading="lazy"></p>
<p>服务器进程为多个客户进程提供服务或资源时，采用不阻塞发送，阻塞接收的消息传递方式较为常见。</p>
<h2 id="33-线程">3.3 线程</h2>
<p><em>线程简介（理解）</em><br>
线程是基本的cpu执行单元，调度和分派的基本单位，程序执行流的最小单位<br>
进程是资源分配的基本单位<br>
一个进程的线程共享该进程的全局变量、打开的文件、I/O资源<br>
<em>多线程（掌握）</em><br>
线程实现与线程模型（理解）<br>
多对一；一对一；多对多<br>
<img src="https://lyhlyhaa.github.io/post-images/1597286385098.png" alt="" loading="lazy"><br>
<strong>注意：一对一优缺点反了</strong></p>
<h2 id="34-互斥和同步">3.4 互斥和同步</h2>
<p>并发原理：临界资源、临界区等多种术语（掌握）<br>
互斥：多个进程因争用临界区内的共享资源而互斥的执行，即当一个进程在临界区访问共享资源时，其它进程不能进入该临界区访问任何共享资源。<br>
同步：系统中有一些相互合作、协同工作的进程，它们之间的相互联系称为进程的同步。<br>
临界区：是一段程序代码，进程将在此代码中访问共享的资源，当另一个进程已经在该代码中运行时，则该进程不能在这段代码中执行。<br>
临界资源：多个进程间采取互斥的方式实现对临界资源的共享访问。<br>
死锁：两个或两个以上的进程因其中的每个进程都在等待其它进程执行完毕而不能继续执行，这样的情形称为死锁。<br>
饥饿：是指一个可运行的进程虽然能继续执行，但被调度程序无限期的忽视而不能执行的情况 。</p>
<p>硬件同步（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597289851472.png" alt="" loading="lazy"><br>
信号量机制（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597307073833.png" alt="" loading="lazy"><br>
管程机制（理解）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597457450240.png" alt="" loading="lazy"><br>
三个经典的进程同步问题（掌握）<br>
生产者-消费者（get） 注意：当缓冲区已满，即empty为0，full为n，若mutex的p操作在前，则会死锁<br>
读者-写者（我裂开了）当一个进程允许并发，和别的互斥，设置整型信号量记录同时运行的进程，并且要设置一个记录型信号量来让这个整型信号量互斥访问<br>
哲学家就餐问题 主要解决死锁问题，（信息量数组）</p>
<p>消息传递（理解）</p>
<h1 id="第4章-调度与死锁">第4章 调度与死锁</h1>
<h2 id="41调度简介理解">4.1调度简介（理解）</h2>
<h2 id="调度的基本概念-调度原则调度原则42-调度算法掌握">调度的基本概念、调度原则<br>
<img src="https://lyhlyhaa.github.io/post-images/1597285417811.png" alt="" loading="lazy"><br>
调度原则：<img src="https://lyhlyhaa.github.io/post-images/1597544207270.png" alt="" loading="lazy"><br>
4.2 调度算法（掌握）</h2>
<p>先来先服务：按进入队列的先后顺序（以等待时间来）<br>
短作业优先：当前已到达的运行时间最短的优先（以服务时间）<br>
最高响应比优先：<br>
<code>响应比：（等待时间+服务时间）/服务时间</code><br>
以上多用于早期的批处理系统中<br>
优先级：每个作业（进程）有各自的优先级，调度时选择优先级最高的进程<br>
<code>有抢占式和非抢占式，会发生饥饿、实时系统</code><br>
时间片轮转：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。(不会饥饿，分时系统)<br>
多级反馈队列（有点复杂，就不写了）：<br>
实时调度：</p>
<h2 id="43-死锁简介">4.3 死锁简介</h2>
<p>资源（理解）<br>
在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推<br>
进的现象，就是“死锁”发生死锁后若无外力干涉，这些进程都将无法向前推进。</p>
<p>死锁产生的原因和必要条件（掌握）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597567271816.png" alt="" loading="lazy"><br>
原因：对系统资源的竞争、程序推进顺序不合法、信号量使用不当</p>
<p>死锁的表示方法和判定（理解）<br>
系统资源分配图，请求边、分配边，进程节点和资源节点</p>
<h2 id="44-死锁预防理解">4.4 死锁预防（理解）</h2>
<p>破坏“请求和保持”条件：要求进程一次性申请所有资源，操作系统阻塞进程直到其所有资源申请得到满足<br>
破坏“不剥夺“条件<br>
破坏”循环等待“条件<br>
破坏”互斥访问“条件（一般不用）</p>
<h2 id="45-死锁避免掌握">4.5 死锁避免（掌握）</h2>
<p>安全状态：存在安全序列就ok，死锁一定是不安全状态、不安全状态不一定死锁<br>
银行家算法数据结构、流程<br>
安全性算法</p>
<h2 id="46-死锁检测和恢复理解">4.6 死锁检测和恢复（理解）</h2>
<p>解除死锁：<br>
1.资源剥夺法<br>
2.撤销进程法<br>
2.进程回退法</p>
<h1 id="第5章-内存管理">第5章 内存管理</h1>
<h2 id="51-概述理解">5.1 概述（理解）</h2>
<p>存储层次结构<br>
存储管理的目的和任务：1.内存分配 2.地址映射 3.内存共享与保护 4.内存扩充</p>
<h2 id="52-地址重定位理解">5.2 地址重定位（理解）</h2>
<p>重定位的基本概念：因为逻辑地址与物理地址不一样<br>
静态重定位：在程序执行之前<br>
动态重定位：在程序执行过程中，需要重定位寄存器<br>
补充：程序的装入、程序的链接</p>
<h2 id="53-分区存储管理连续分配">5.3 分区存储管理（连续分配）</h2>
<p>注意：内部碎片：分配给某进程的内存区域中，某些没有用上的部分<br>
外部碎片：内存中某些空闲分区太小难以利用</p>
<p>单一连续：任何时刻内存中只能能有一道用户程序<br>
固定分区、可变分区分配（理解）</p>
<p>分区分配算法（掌握）<br>
首次适应算法：从低地址开始查找，找到第一个能满足大小的空闲分区<br>
最佳适应算法：<br>
最坏适应算法：<br>
循环首次适应算法：<br>
补充：哈希算法、伙伴系统（理解）</p>
<h2 id="54-页式存储管理非连续分配">5.4 页式存储管理（非连续分配）</h2>
<p>页：把用户进程的地址空间分为与物理块大小相等的一个个区域，称为页或页面<br>
页号=逻辑地址/页面长度(取除法的整数部分)<br>
页内偏移量=逻辑地址%页面长度(取除法的余数部分)<br>
<img src="https://lyhlyhaa.github.io/post-images/1597756802838.png" alt="" loading="lazy"><br>
块：内存等分称为块<br>
页表（每一个进程有自己的页表）、地址结构、</p>
<p>分页地址变换、<img src="https://lyhlyhaa.github.io/post-images/1597755784851.png" alt="" loading="lazy"><br>
页表长度表示有多少个页<br>
<em><strong>页表项是指页表中的一行？</strong></em><br>
快表（掌握）考察访问时间<br>
通常系统中，先访问快表，未命中时再访问内存；在有些系统中，快表与内存的访问同时进行，当快表命中时就停止对内存的访问。这里题目未具体指明，我们按照前者进行计算。但如果题中有具体的说明，计算时则应注意区别。<br>
计算过程：[(0.2+1)×85%+(0.2+1+1)×(1-85%)]μs=1.35μs。</p>
<p>两级页表、多级页表（理解）</p>
<h2 id="55-段式与段页式存储管理">5.5 段式与段页式存储管理</h2>
<p>段、段表、地址结构、分段地址变换（掌握）<br>
段的逻辑地址由段号和段内地址所组成。<br>
每个段在表中占有一个表项，其中记录了该段在内存中的起始地址（基址）和段的长度（段长）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597980322934.png" alt="" loading="lazy"><br>
分页和分段的区别（掌握）<br>
(1) 页是信息的物理单位，仅仅是出于系统管理的需要；段是信息的逻辑单位，其目的是满足用户的需要。<br>
(2) 页的大小固定且由系统确定，一个系统只能有一种大小的页面；段的长度不固定，决定于用户所编写的程序；<br>
(3) 分页的作业地址空间是一维的；分段的作业地址空间是二维的。<br>
(4) 通常分段的段内空间会比分页的页面空间大，因此段表会比页表短。</p>
<p>段页式存储管理（理解）</p>
<h2 id="56-内存扩充技术了解">5.6 内存扩充技术（了解）</h2>
<p>覆盖、交换</p>
<h2 id="57-虚拟存储管理">5.7 虚拟存储管理</h2>
<p>基本原理：局部性原理、虚拟存储器（理解）<br>
(1) 时间局限性。程序中的某条指令被执行，不久后会再次执行；某个数据被访问，不久后将再次被访问。产生时间局限性的典型原因是在程序中存在着大量的循环操作。<br>
(2) 空间局限性。 程序访问了某个存储单元，不久后，其附近的存储单元也将被访问。</p>
<p>请求分页存储管理（理解）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597822969611.png" alt="" loading="lazy"><br>
页面置换算法：<br>
最佳置换：每次选择淘汰的页面将是以后永不使用，或者再最长时间内不再被访问的页面，这样可以保证最低的缺页率。（无法实现，用来衡量算法好坏）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597826381870.png" alt="" loading="lazy"><br>
先进先出置换算法（FIFO）：每次淘汰的页面是最早进入内存的页面，可能有beledy异常<br>
最近最久未使用置换算法（LRU）：每次淘汰的页面时最近最久未使用的页面（逆向扫描😕，实现开销比较大，性能好）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597825736996.png" alt="" loading="lazy"><br>
时钟置换算法（CLOCK）：<br>
第二次机会（NRU），就是第二个：<br>
请求分页存储管理系统性能分析：缺页率、抖动、页面大小（理解）<br>
缺页率：缺页中断次数/总次数；<br>
抖动：如此频繁地更换页面，以至一个进程在运行中，将把大部分时间花在完成页面置换的工作上，我们称该进程发生了“抖动”。抖动现象分为局部抖动和全局抖动两种类型。</p>
<p>请求分段存储管理（理解）</p>
<h1 id="第6章-设备管理">第6章 设备管理</h1>
<h2 id="61-概述理解">6.1 概述（理解）</h2>
<p>设备管理的的目标和任务<br>
I/O系统结构：<br>
I/O设备分为机械部件和电子部件（I/O控制器，一个可以控制多个设备）<br>
I/O设备分类</p>
<h2 id="62-io系统控制方式掌握">6.2 I/O系统控制方式（掌握）</h2>
<p>程序直接控制方式<br>
中断控制方式<img src="https://lyhlyhaa.github.io/post-images/1597894847490.png" alt="" loading="lazy"><br>
DMA控制方式<img src="https://lyhlyhaa.github.io/post-images/1597895507112.png" alt="" loading="lazy"><br>
通道控制方式<img src="https://lyhlyhaa.github.io/post-images/1597895746989.png" alt="" loading="lazy"></p>
<h2 id="63-io软件的组成">6.3 I/O软件的组成</h2>
<p>I/O软件设计目标和原则（理解）<br>
I/O软件结构（理解）<br>
<img src="https://lyhlyhaa.github.io/post-images/1597910317722.png" alt="" loading="lazy"><br>
设备驱动程序（了解）<br>
I/O设备的控制方式（掌握）<br>
设备无关软件（了解）<br>
用户层软件：<br>
SPOOLing技术（假脱机技术）的引入、组成和特点（理解）<br>
所谓脱机就是脱离主机控制的输入输出<br>
<img src="https://lyhlyhaa.github.io/post-images/1597911772456.png" alt="" loading="lazy"></p>
<h2 id="64-具有通道的设备管理">6.4 具有通道的设备管理</h2>
<p>通道类型（掌握）</p>
<h2 id="65-设备管理相关技术">6.5 设备管理相关技术</h2>
<p>DMA（理解）<br>
缓冲技术：<br>
缓存区作用：<br>
（1）可以改善CPU与I/O设备间速度不匹配的矛盾。<br>
（2）可以减少对 CPU的中断频率，放宽对中断响应时间的限制。<br>
（3）可以提高 CPU和 I/O设备之间的并行性。<br>
<img src="https://lyhlyhaa.github.io/post-images/1597913868957.png" alt="" loading="lazy"><br>
单缓冲（一个缓冲区）、双缓冲（两个缓冲）、循环缓冲区和缓冲池（理解）</p>
<p>总线技术（不考）</p>
<h2 id="66-磁盘存储管理">6.6 磁盘存储管理</h2>
<p>磁盘简述：磁盘的定义、组成、磁盘访问时间（理解）<br>
磁盘调度：FCFS、SSTF、SCAN、C-SCAN、N步扫描、F-SCAN（掌握）<br>
磁盘管理（不考）<br>
容错技术：容错技术的概念、廉价磁盘冗余阵列（理解）</p>
<h1 id="第7章-文件管理">第7章 文件管理</h1>
<p>7.1 概述（理解）<br>
文件、文件系统的定义<br>
7.2 文件结构<br>
逻辑结构（理解）<br>
索引文件，<img src="https://lyhlyhaa.github.io/post-images/1597930086320.png" alt="" loading="lazy"><br>
物理结构：顺序结构、链接结构、索引结构（掌握）；<br>
直接文件、哈希文件（理解）<br>
7.3 文件目录<br>
文件控制块FCB（掌握）<br>
为了实现按名存取，一个文件对应一个FCB，一个FCB就是一个目录项，多个FCB组成文件目录<br>
索引节点（掌握）：把文件控制块中除了文件名之外的文件描述信息放到一个索引结点指针中，加快了文件检索速度<br>
目录结构：单级（只有一个目录表）、两级（两个）和多级（多个）（了解）<br>
目录查询（了解）<br>
绝对路径：从根目录出发 相对路径：从当前目录出发<br>
7.4 文件共享和安全（理解）<br>
文件共享：符号链接实现共享、索引节点实现共享（理解）<br>
文件安全：存取控制矩阵、存取控制表、用户权限表、口令方法（了解）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1286 比赛]]></title>
        <id>https://lyhlyhaa.github.io/post/1286-bi-sai/</id>
        <link href="https://lyhlyhaa.github.io/post/1286-bi-sai/">
        </link>
        <updated>2020-07-30T08:24:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>有n名选手参加比赛，从1∼n编号。每场比赛由两位选手对决，失败的被淘汰。为了增加比赛的观赏性，举办方并不想比赛双方实力相差太大的，所以决定，每场比赛的两位选手，之前胜场次数之差不能超过1。同时，鸡贼的举办方又不想冠军选手比赛太少了（严重影响比赛收入），希望冠军选手比赛场次越多越好。作为选手的你，当然不希望夺冠路上比赛场次太多，请问在这个赛制下，冠军最多比赛多少场？</p>
<h2 id="输入">输入</h2>
<p>存在不超过10000组样例。每行一个整数n(1≤n≤1018)。</p>
<h2 id="输出">输出</h2>
<p>每行输出一个样例的结果，为一个整数。</p>
<h2 id="样例输入">样例输入</h2>
<p>1<br>
2<br>
3<br>
10<br>
1000000000000000000</p>
<h2 id="样例输出">样例输出</h2>
<p>0<br>
1<br>
2<br>
4<br>
85</p>
<hr>
<p>全部比赛看作一棵树<br>
<img src="https://lyhlyhaa.github.io/post-images/1596097884622.jpg" alt="" loading="lazy"><br>
n 很容易看出来是一个斐波那契数列，之后设置一个数组记录，很容易就完成了<br>
g(1)=1   g(2)=2<br>
g(h)=g(h-1)+g(h-2)<br>
<img src="https://lyhlyhaa.github.io/post-images/1596098127037.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计网-链路层]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-wang-lian-lu-ceng/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-wang-lian-lu-ceng/">
        </link>
        <updated>2020-07-29T02:41:35.000Z</updated>
        <content type="html"><![CDATA[<p>作业三</p>
<ol>
<li>要发送的数据为101110。采用CRC的生成 多项式是P（X）＝X3＋1。试求应添加在数据后面的余数<br>
解：<br>
被除数为101110000，除数为1001，得到余数为011。<br>
<strong>CRC校验码</strong><br>
在发送端，先把数据划分为组。假定每组 k 个比特。<br>
假设待传送的一组数据 M = 101001（现在 k = 6）。我们在数据M 的后面再添加供差错检测用的 n 位冗余码一起发送。<br>
用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。<br>
得到的 (k + n) 位的新数Mx除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少1 位，即 R 是 n 位,为冗余码。<br>
*注意：在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence) *<br>
<img src="https://lyhlyhaa.github.io/post-images/1596007436517.png" alt="" loading="lazy"><br>
<img src="https://lyhlyhaa.github.io/post-images/1596007443448.png" alt="" loading="lazy"></li>
</ol>
<hr>
<ol>
<li>PPP协议使用同步传输技术传送比特串 0110111111111100。试问经过零比特填充后变成 怎样的比特串？若接收端收到的PPP帧的数据部 分是0001110111110111110110，问删除发送端加 入的零比特后变成怎样的比特串？<br>
解：<br>
原比特串：011011111  11111 00    填充后：011011111011111000<br>
原比特串：0001110111110111110110    删除后：000111011111 11111 110<br>
<strong>零比特填充</strong>：在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除，还原信息 。<br>
<strong>PPP协议</strong>：全世界使用得最多的数据链路层协议是点对点协议 ，用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。</li>
</ol>
<hr>
<p>3.　 假定1km长的CSMA/CD网络的数据率为 1Gbit/s。设信号在网络上的传播速率为 200000km/s。求能够使用此协议的最短帧长。<br>
解：对于1km电缆，单程传播时间为1/200000=5微秒，来回路程传播时间为10微秒，为了能够按照CSMA/CD工作，最小帧的发射时间不能小于10微秒，以Gb/s速率工作，10微秒可以发送的比特数等于10<em>10<sup>-6/1*10</sup>-9=10000,因此，最短帧是10000位或1250字节长<br>
 <strong>CSMA/CD协议</strong>：载波监听多点接入/碰撞检测  CSMA/CD，“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。<br>
以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。<br>
单程端到端传播时延记为τ<br>
最短有效帧长 ：数据率</em>2τ</p>
<hr>
<ol>
<li>以太网上只有两个站，它们同时发送数据，产生了碰撞。于是按截断二进制指数退避算法进行重传。重传次数记为i，i＝1，2，3，…。 试计算第1次重传失败的概率、第2次重传失败的概率、第3次重传失败的概率，以及一个站成功发送数据之前的平均重传次数I。<br>
解：<br>
将第i次重传成功的概率记为pi。显然第一次重传失败的概率为0.5，第二次重传失败的概率为0.25，第三次重传失败的概率为0.125.平均重传次数I=1.637 <br>
<a href="https://blog.csdn.net/xingchenhy/article/details/72848029">二进制指数类型退避算法 (truncated binary exponential type):</a></li>
</ol>
<hr>
<p>5.　 假定在图3-30中的所有链路的速率仍然为 100Mbit/s，但所有的以太网交换机都换成为 100Mbit/s的集线器。试计算这9台主机和两个服务器产生的总的吞吐量的最大值。为什么<br>
<img src="https://lyhlyhaa.github.io/post-images/1596164216859.jpg" alt="" loading="lazy"><br>
解：<br>
<em>集线器很像一个多接口的转发器，工作在物理层</em><br>
一个网络中无论有多少台服务器和主机，如果全部连接在一个集线器上，那么该网络最大吞吐量 = 集线器最大值。如果接口全部与交换机相连，那么最大吞吐量 = Σ 各链路最大值<br>
吞吐量 = 整个系统 = 100 Mbit</p>
<hr>
<p>补充问答题<br>
家中电脑TCP/IP属性中默认网关是指哪一个端口（在家的拓扑图标出）？怎样查看这个接口的IP地址(查看的步骤）？解：<br>
Windows10中可以打开设置，打开网络与Internet，打开状态，点击查看网络属性，就可以看到该接口的ip地址。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计网-物理层]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-wang-wu-li-ceng/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-wang-wu-li-ceng/">
        </link>
        <updated>2020-07-28T11:44:36.000Z</updated>
        <content type="html"><![CDATA[<p>1.假定某信道受奈氏准则限制的最高码元速率为20000码元/秒。如果采用振幅调制，把码元的振幅划分为16个不同等级来传送，那么可以获得多高的数据率（bit/s）？<br>
解：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>R</mi><mo>∗</mo><mi>L</mi><mi>o</mi><mi>g</mi><mn>2</mn><mi mathvariant="normal">（</mi><mn>16</mn><mi mathvariant="normal">）</mi><mo>=</mo><mn>20000</mn><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>∗</mo><mn>4</mn><mo>=</mo><mn>80000</mn><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">C=R*Log2（16）=20000b/s*4=80000b/s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mord">6</span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span></span></p>
<p>最基本的二元制调制方法有以下几种：<br>
调幅(AM)：载波的振幅随基带数字信号而变化。<br>
调频(FM)：载波的频率随基带数字信号而变化。<br>
调相(PM) ：载波的初始相位随基带数字信号而变化。<br>
调制方法就是改变码元携带的比特的信息，码元传输速率一般固定，调制之后，传输比特的速率就上升了</p>
<hr>
<p>2.用香农公式计算一下，假定信道带宽为3100Hz，最大信息传输速率为35kbit/s，那么若想使最大信息传输速率增加60％，问信噪比S/N应增大到多少倍？如果在刚才计算出的基础上将信噪比S/N再增大到10倍，问最大信息速率能否再增加20％？<br>
解：<br>
C=Wlog2(1+S/N)b/s-àSN1=2*（C1/W）-1=2*（35000/3100）-1<br>
SN2=2*（C2/W）-1=2*（1.6<em>C1/w）-1=2</em>（1.6<em>35000/3100）-1<br>
SN2/SN1=100信噪比应增大到约100倍。C3=Wlong2（1+SN3）=Wlog2（1+10</em>SN2）C3/C2=18.5%如果在此基础上将信噪比S/N再增大到10倍，最大信息通率只能再增加18.5%左右</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">香</mi><mi mathvariant="normal">农</mi><mi mathvariant="normal">公</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">：</mi><mi>C</mi><mo>=</mo><mi>W</mi><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>(</mo><mn>1</mn><mo>+</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo>)</mo><mo>(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">香农公式：C = W log2(1+S/N) (bit/s)   
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">香</span><span class="mord cjk_fallback">农</span><span class="mord cjk_fallback">公</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></span></p>
<p>W 为信道的带宽（以 Hz 为单位）<br>
信噪比（dB）：10 log10(S/N) (dB)<br>
S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率</p>
<hr>
<p>3.　假定有一种双绞线的衰减是0.7dB/km（在1kHz时），若容许有20dB的衰减，试问使用这种双绞线的链路的工作距离有多长？如果要使这种双绞线的工作距离增大到100公里，问应当使衰减降低到多少？<br>
解：使用这种双绞线的链路的工作距离为=20/0.7=28.6km   衰减应降低到20/100=0.2db</p>
<hr>
<p>4.共有四个站进行码分多址CDMA通信。四个站的码片序列为：<br>
A：（–1–1–1＋1＋1–1＋1＋1）<br>
B：（–1–1＋1–1＋1＋1＋1–1）<br>
C：（–1＋1–1＋1＋1＋1–1–1）<br>
D：（–1＋1–1–1–1–1＋1–1）<br>
现收到这样的码片序列:（–1＋1–3＋1–1–3＋1＋1）。问哪个站发送数据了？发送数据的站发送的是1还是0？<br>
解：<br>
S•A=（＋1－1＋3＋1－1＋3＋1＋1）／8=1，A发送1<br>
S•B=（＋1－1－3－1－1－3＋1－1）／8=－1，B发送0<br>
S•C=（＋1＋1＋3＋1－1－3－1－1）／8=0，C无发送<br>
S•D=（＋1＋1＋3－1＋1＋3＋1－1）／8=1，D发送1</p>
<p>码片序列：<br>
每个站被指派一个唯一的 m bit 码片序列。<br>
如发送比特 1，则发送自己的 m bit 码片序列。<br>
如发送比特 0，则发送该码片序列的二进制反码<br>
为表示方便，将0写为-1，1写为+1</p>
<p><strong>注意：两个不同站的码片序列正交</strong><br>
不同站的码片向量规格化内积为0<br>
任何一个码片向量和该码片向量自己的规格化内积都是1 。<br>
一个码片向量和该码片反码的向量的规格化内积值是 –1。</p>
<hr>
<p>5.　试比较ADSL、HFC以及FTTx接入技术的优缺点。解：<br>
ADSL技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。成本低，易实现，但带宽和质量差异性大。HFC网的最大的优点具有很宽的频带，并且能够利用已经有相当大的覆盖面的有线电视网。要将现有的450MHz单向传输的有线电视网络改造为750MHz双向传输的HFC网需要相当的资金和时间。FTTx（光纤到……）这里字母x可代表不同意思。可提供最好的带宽和质量、但现阶段线路和工程成本太大。</p>
<p>补充问答题1、怎样更改自己电脑的MAC地址（用文字描述操作步骤）解：</p>
<p>打开设备管理器<br>
右键点击适配器。从菜单中点击属性来打开网络适配器的属性窗口。<br>
点击高级选项卡。找到“网络地址”或“本地管理地址”条目。点击该条目，将在右侧看到“值”（Value）的字样和输入框。点击单选按钮来启用“值”（Value）的输入框。<br>
输入新的MAC地址。MAC地址的格式是，不包含破折号和冒号的12位数值。<br>
重启计算机来启用变更。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小生成树]]></title>
        <id>https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/">
        </link>
        <updated>2020-07-26T07:00:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="克鲁斯卡尔算法">克鲁斯卡尔算法：</h1>
<p>1.把边进行排序，按从从小到大的顺序。<br>
2.贪心算法，找未加入通路的权值最小的边<br>
3.判断是否形成环，如果形成，则跳过这一条边，返回第二步，如果没有，则把找到的边加入通路中，返回第二步<br>
4.当通路中的的边的个数等于点的个数-1，则最小生成树已经形成。</p>
<p><em>排序可以用sort函数，边的存储可以用结构体数组</em><br>
<strong>主要是判断是否形成环：</strong><br>
使用<a href="https://blog.csdn.net/qq_41593380/article/details/81146850">并查集</a><br>
<strong>初始化</strong></p>
<pre><code>void init(int n)
{
    for (int i = 1; i &lt;= n; ++i)
        fa[i] = i;
}
</code></pre>
<p><strong>路径压缩查找</strong></p>
<pre><code>int find(int x)
{
    return x == fa[x] ? x : (fa[x] = find(fa[x]));//
}
</code></pre>
<p><strong>合并</strong></p>
<pre><code>ivoid merge(int i, int j)
{
    fa[find(i)] = find(j);
}//合并
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐波拉契数列]]></title>
        <id>https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/</id>
        <link href="https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/">
        </link>
        <updated>2020-07-24T07:30:17.000Z</updated>
        <content type="html"><![CDATA[<p>。。。。<br>
今晚整理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[骨牌问题（铺地砖）]]></title>
        <id>https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/</id>
        <link href="https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/">
        </link>
        <updated>2020-07-24T07:14:41.000Z</updated>
        <content type="html"><![CDATA[<p>暂时看一下别的博客（https://blog.csdn.net/xiangAccepted/article/details/80229187?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三色旗问题]]></title>
        <id>https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/</id>
        <link href="https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/">
        </link>
        <updated>2020-07-24T02:54:57.000Z</updated>
        <content type="html"><![CDATA[<p>要用到三个指针：一个前指针begin，一个中指针current，一个后指针end，current指针遍历整个数组序列，当</p>
<p>current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ；<br>
current指针所指元素为1时，不做任何交换（即球不动），而后current++ ；<br>
current指针所指元素为2时，与end指针所指的元素交换，而后，current指针不动，end-- 。</p>
]]></content>
    </entry>
</feed>