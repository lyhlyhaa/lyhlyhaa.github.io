<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lyhlyhaa.github.io</id>
    <title>混子协会会长</title>
    <updated>2020-07-28T08:39:46.274Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lyhlyhaa.github.io"/>
    <link rel="self" href="https://lyhlyhaa.github.io/atom.xml"/>
    <logo>https://lyhlyhaa.github.io/images/avatar.png</logo>
    <icon>https://lyhlyhaa.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 混子协会会长</rights>
    <entry>
        <title type="html"><![CDATA[最小生成树]]></title>
        <id>https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/zui-xiao-sheng-cheng-shu/">
        </link>
        <updated>2020-07-26T07:00:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="克鲁斯卡尔算法">克鲁斯卡尔算法：</h1>
<p>1.把边进行排序，按从从小到大的顺序。<br>
2.贪心算法，找未加入通路的权值最小的边<br>
3.判断是否形成环，如果形成，则跳过这一条边，返回第二步，如果没有，则把找到的边加入通路中，返回第二步<br>
4.当通路中的的边的个数等于点的个数-1，则最小生成树已经形成。</p>
<p><em>排序可以用sort函数，边的存储可以用结构体数组</em><br>
<strong>主要是判断是否形成环：</strong><br>
使用<a href="https://blog.csdn.net/qq_41593380/article/details/81146850">并查集</a><br>
<strong>初始化</strong></p>
<pre><code>void init(int n)
{
    for (int i = 1; i &lt;= n; ++i)
        fa[i] = i;
}
</code></pre>
<p><strong>路径压缩查找</strong></p>
<pre><code>int find(int x)
{
    return x == fa[x] ? x : (fa[x] = find(fa[x]));//
}
</code></pre>
<p><strong>合并</strong></p>
<pre><code>ivoid merge(int i, int j)
{
    fa[find(i)] = find(j);
}//合并
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐波拉契数列]]></title>
        <id>https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/</id>
        <link href="https://lyhlyhaa.github.io/post/fei-bo-la-qi-shu-lie/">
        </link>
        <updated>2020-07-24T07:30:17.000Z</updated>
        <content type="html"><![CDATA[<p>。。。。<br>
今晚整理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[骨牌问题（铺地砖）]]></title>
        <id>https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/</id>
        <link href="https://lyhlyhaa.github.io/post/gu-pai-wen-ti-pu-di-zhuan/">
        </link>
        <updated>2020-07-24T07:14:41.000Z</updated>
        <content type="html"><![CDATA[<p>暂时看一下别的博客（https://blog.csdn.net/xiangAccepted/article/details/80229187?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三色旗问题]]></title>
        <id>https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/</id>
        <link href="https://lyhlyhaa.github.io/post/san-se-qi-wen-ti/">
        </link>
        <updated>2020-07-24T02:54:57.000Z</updated>
        <content type="html"><![CDATA[<p>要用到三个指针：一个前指针begin，一个中指针current，一个后指针end，current指针遍历整个数组序列，当</p>
<p>current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ；<br>
current指针所指元素为1时，不做任何交换（即球不动），而后current++ ；<br>
current指针所指元素为2时，与end指针所指的元素交换，而后，current指针不动，end-- 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络（考试）]]></title>
        <id>https://lyhlyhaa.github.io/post/ji-suan-ji-wang-luo/</id>
        <link href="https://lyhlyhaa.github.io/post/ji-suan-ji-wang-luo/">
        </link>
        <updated>2020-07-23T08:31:33.000Z</updated>
        <content type="html"><![CDATA[<p><em>图文无关😂</em></p>
<hr>
<p>(1)	Socket是由（ 　D    ）组成的。<br>
A.主机名   <strong>B. MAC地址及端口号</strong><br>
C.IP地址以及MAC地址       D. IP地址及端口号<br>
(2)	　在OSI参考模型中，实现系统间二进制信息块的正确传输，为上一层提供可靠、无错误数据信息的协议层是(   A    ) 。<br>
<strong>A. 数据链路层</strong>     B. 物理层        C. 网络层    D. 传输层<br>
(3) 在TCP/IP网络中，提供主机A和主机B应用层之间通信的层是（   B ）。<br>
A、应用层         <strong>B.传输层</strong>        C、IP层       D、网络接口层；<br>
<strong>在TCP/IP四层模型中，提供两主机应用层之间通信的层是传输层，传输层通过端口值来实现两台主机应用程序的通信。IP层则是负责提供机器之间的通信，IP层通过IP地址来标识不同的主机，实现机器之间的通信</strong><br>
(4) 路由器主要实现了（  C  ）的功能。<br>
A. 数据链路层、网络层与应用层  　  　 B. 物理层、数据链路层与网络层<br>
　     <strong>C. 网络层与传输层</strong>　　　　　　　　    　D. 物理层与传输层<br>
(5) 当客户端请求域名解析时，如果本地DNS服务器不能完成解析，就把请求发送其他服务器，依次进行查询，直到把域名解析结果返回请求的客户端，这种方式（  B  ）<br>
A. 迭代解析               　　 <strong>B. 迭代解析与递归解析相结合</strong><br>
C. 递归解析　　　　　　　　　　D.高速缓存解析<br>
(6)关于TCP和UDP下列说法中正确的是（A    ）。<br>
<strong>A．TCP和UDP端口分别拥有自己的端口号，二者互不干扰，可以共存于同一台主机；</strong>　　<br>
B．TCP和UDP端口分别拥有自己的端口号，但二者不能共存于同一台主机；<br>
C．TCP和UDP端口没有本质区别，二者互不干扰，可以共存于同一台主机；<br>
D．TCP和UDP端口没有本质区别，但二者相互干扰，不能共存于同一台主机；<br>
(7) 一条线路每1/16秒采样一次，传输信号共有16种状态，器传输速率是（  C ）。<br>
A. 16bps          B. 48bps     ** C. 64bps**          D. 256bps<br>
<strong>16种状态可以用4bit二进制数表示，每秒采样16次，所以每秒需要传的数据量就是64bit。如果不考虑信道编码需要增加的冗余比特，传输速率就是64bit/s。</strong><br>
(8) 关于客户/服务器应用模式，以下（  A ）说法是正确的。<br>
<strong>A. 由服务器和客户机协同完成一件任务；</strong>　　B. 在服务器端，每次只能为一个客户服务；<br>
C. 将应用程序下载到本地执行；　　　　　　D.许多终端共享主机资源的多用户系统；<br>
(9)一个16端口的二层以太交换机，冲突域和广播域的个数分别是(      )。<br>
　　　A. １，１        B . １６，１６      C. １，１６        <strong>D . １６，１</strong><br>
<img src="https://lyhlyhaa.github.io/post-images/1595924992303.png" alt="" loading="lazy"></p>
<p>二、	填空题（每题2分，共20分）<br>
<img src="https://lyhlyhaa.github.io/post-images/1595925256313.png" alt="" loading="lazy"><br>
1.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路径算法]]></title>
        <id>https://lyhlyhaa.github.io/post/zui-duan-lu-jing-suan-fa/</id>
        <link href="https://lyhlyhaa.github.io/post/zui-duan-lu-jing-suan-fa/">
        </link>
        <updated>2020-07-22T12:05:34.000Z</updated>
        <content type="html"><![CDATA[<p>说起来这个算法做过很多次了，学图论的时候写过实验报告，可是现在做题又给忘了，惭愧。</p>
<hr>
<h1 id="dijkstra算法">Dijkstra算法</h1>
<p>1.<strong>初始化</strong>:先找出从源点vo到各终点v的直达路径(Vo,Vk) ,<br>
即通过一条弧到达的路径。<br>
2.<strong>选择</strong>:从这些路径中找出一条长度最短的路径(Vo,u) 。<br>
3.<strong>更新</strong>:然后对其余各条路径进行适当调整:<br>
若在图中存在弧(u,Vk) ，且(V,U) + (u,Vk) &lt; (Vo,Vk),<br>
则以路径(Vo,U,Vk) 代替(Vo,Vk) 。<br>
在调整后的各条路径中，再找长度最短的路径，依此类推。<br>
设计一个s[]数组，来存已经在最短路径中的点</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dp]]></title>
        <id>https://lyhlyhaa.github.io/post/dp/</id>
        <link href="https://lyhlyhaa.github.io/post/dp/">
        </link>
        <updated>2020-07-22T01:53:51.000Z</updated>
        <content type="html"><![CDATA[<p>先是不说人话的概念：dp（动态规划）是求解决策过程最优化的数学方法。利用各个阶段之间的关系，逐个求解，最终求得全局最优解，需要确认原问题与子问题、动态规划状态、边界状态、边界状态结值、状态转移方程<br>
看不懂啊！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈]]></title>
        <id>https://lyhlyhaa.github.io/post/zhan/</id>
        <link href="https://lyhlyhaa.github.io/post/zhan/">
        </link>
        <updated>2020-07-21T01:59:07.000Z</updated>
        <content type="html"><![CDATA[<p>栈（stack）说明及举例：</p>
<p>使用栈，要先包含头文件 ： <code>#include&lt;stack&gt;</code></p>
<p>定义栈，以如下形式实现： <code>stack&lt;Type&gt; s;</code> 其中Type为数据类型（如 int，float,char等）。</p>
<p>栈的主要操作：</p>
<pre><code>s.push(item);		//将item压入栈顶
s.pop();			//删除栈顶的元素，但不会返回
s.top();			//返回栈顶的元素，但不会删除
s.size();			//返回栈中元素的个数
s.empty();			//检查栈是否为空，如果为空返回true，否则返回false 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[指针疑问]]></title>
        <id>https://lyhlyhaa.github.io/post/zhi-zhen-yi-wen/</id>
        <link href="https://lyhlyhaa.github.io/post/zhi-zhen-yi-wen/">
        </link>
        <updated>2020-07-20T09:05:40.000Z</updated>
        <content type="html"><![CDATA[<p>指针<br>
*号：指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。* 运算符，也称为间接访问运算符，返回指针指向存储单元的数值；也称为指向运算符号：<br>
注意：<br>
指针运算符是取地址运算符号的反运算符号<br>
*(&amp;a) = 10;<br>
&amp;号：每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址，&amp;运算符，返回操作数的内存地址</p>
<pre><code class="language-cpp">int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
   ip = &amp;var;  /* 在指针变量中存储 var 的地址 */
   printf(&quot;Address of var variable: %p\n&quot;, &amp;var  );//Address of var variable: bffd8b3c
   /* 在指针变量中存储的地址 */
   printf(&quot;Address stored in ip variable: %p\n&quot;, ip );//Address stored in ip variable: bffd8b3c
   /* 使用指针访问值 */
   printf(&quot;Value of *ip variable: %d\n&quot;, *ip );//Value of *ip variable: 20
</code></pre>
<p><strong>突然想起来定义的时候，int *p就是int* p,其实是相当于一个int*类型的变量p，p就是一个地址值，简而言之，p是一个地址值，而*p就是p所指向的东西，可以是一个整型变量，也可以指向一个链表节点，也可以是一个二叉树节点。</strong></p>
<pre><code class="language-cpp"> int a=1;
 int *pa;
 pa=&amp;a; //&amp;a 是一个指针表达式。
 printf(&quot;*a=%p\n&quot;,&amp;a);
 printf(&quot;*pa=%d\n&quot;,*pa);//*pa是一个值，就是pa所指向的a的值 
 printf(&quot;pa=%p\n&quot;,pa);//pa是一个地址，pa指向a，所以pa地址与a相同 
 printf(&quot;&amp;*pa=%p\n&quot;,&amp;(*pa));//pa指向a，*pa就是a,&amp;(*pa)即*pa的地址就是a的地址 
 /*
 *a=000000000062FE14
 *pa=1
 pa=000000000062FE14
 &amp;*pa=000000000062FE14
 */
 printf(&quot;\n&quot;); 
 int** ptr;
 ptr=&amp;pa;//由此可知*ptr=pa、**ptr=*pa 
 printf(&quot;&amp;pa=%p\n&quot;,&amp;pa);//pa指针本身的地址 
 printf(&quot;ptr=%p\n&quot;,ptr);//ptr指向的是pa本身地址 
 printf(&quot;*ptr=%p\n&quot;,*ptr);//*ptr指向的是pa指针所指向的地址，就是a的地址
 printf(&quot;**p=%d\n&quot;,**ptr);// 
 /*
 &amp;pa=000000000062FE08
 *ptr=000000000062FE14
 ptr=000000000062FE08
 **p=1
 */
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树]]></title>
        <id>https://lyhlyhaa.github.io/post/er-cha-shu/</id>
        <link href="https://lyhlyhaa.github.io/post/er-cha-shu/">
        </link>
        <updated>2020-07-20T02:39:20.000Z</updated>
        <content type="html"><![CDATA[<p>首先说一下一些基础知识。（查了一下，树的高度和深度好像有不同的说法，似乎初始值有 0 有 1）</p>
<h1 id="基础知识">基础知识</h1>
<p><em><strong>树的高度</strong></em>：<br>
节点的深度是根节点到这个节点所经历的边的个数<br>
节点的高度是该节点到叶子节点的最长路径（边数）<br>
树的高度等于根节点的高度<br>
<img src="https://lyhlyhaa.github.io/post-images/1595213437405.png" alt="" loading="lazy"><br>
（好像有些是从1开始的）<br>
递归计算高度</p>
<pre><code>int height(BitNode *root){
	if(root==NULL) return 0;
	else 
	return max(height(root-&gt;lchild),height(root-&gt;rchild))+1;
}//求二叉树的高度
</code></pre>
<h1 id="二叉查找树">二叉查找树</h1>
<h2 id="定义">定义</h2>
<p><em><strong>二叉查找树</strong></em><br>
一棵空树，或者是具有下列性质的二叉树：<br>
（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>
（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>
（3）左、右子树也分别为二叉排序树；<br>
（4）没有键值相等的结点。<br>
可以用递归建树，似乎涉及二叉树的题目，大部分是递归。</p>
<h2 id="建树">建树</h2>
<p>要建立一个二叉查找树，首先要定义一个结构体，一般来说定义的结构体都是一样的；</p>
<pre><code>typedef struct BitNode{
   int data;
   struct BitNode *lchild, *rchild; 
}BitNode,*BiTree;
</code></pre>
<p>一个数据域，还有左右节点。<br>
插入函数：</p>
<pre><code>bool BSTInsert(BitNode *p, int element)  //插入函数 
{  
    if(NULL == p) // 空树  
    {  
        p = new BitNode;  
        p-&gt;data = element;  
        p-&gt;lchild = p-&gt;rchild = NULL;  
        return true;  
    }  
    if(element == p-&gt;data) // BST中不能有相等的值  
        return false;  
    if(element &lt; p-&gt;data)  // 递归  
        return BSTInsert(p-&gt;lchild, element);  

    return BSTInsert(p-&gt;rchild, element); // 递归  
}
</code></pre>
]]></content>
    </entry>
</feed>